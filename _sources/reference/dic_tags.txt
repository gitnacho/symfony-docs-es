Etiquetas de inyección de dependencias
======================================

Etiquetas:

* ``data_collector``
* ``form.type``
* ``form.type_extension``
* ``form.type_guesser``
* ``kernel.cache_warmer``
* ``kernel.event_listener``
* ``monolog.logger``
* ``monolog.processor``
* ``templating.helper``
* ``routing.loader``
* ``translation.loader``
* ``twig.extension``
* ``validator.initializer``

Habilitando ayudantes de plantilla *PHP* personalizados
-------------------------------------------------------

Para habilitar un ayudante de plantilla personalizado, añádelo como un servicio regular en tu configuración, etiquétalo con ``templating.helper`` y define un atributo ``alias`` (el ayudante será accesible a través de este alias en las plantillas):

.. configuration-block::

    .. code-block:: yaml

        services:
            templating.helper.your_helper_name:
                class: Nombre\De\Clase\Ayudante\Completamente\Cualificado
                tags:
                        - { name: templating.helper, alias: alias_name }

    .. code-block:: xml

        <service id="templating.helper.your_helper_name" class="Nombre\De\Clase\Ayudante\Completamente\Cualificado">
            <tag name="templating.helper" alias="alias_name" />
        </service>

    .. code-block:: php

        $container
            ->register('templating.helper.your_helper_name', 'Nombre\De\Clase\Ayudante\Completamente\Cualificado')
            ->addTag('templating.helper', array('alias' => 'alias_name'))
        ;

.. _reference-dic-tags-twig-extension:

Habilitando extensiones *Twig* personalizadas
---------------------------------------------

Para habilitar una extensión *Twig*, añádela como un servicio regular en tu configuración, y etiquétala con ``twig.extension``:

.. configuration-block::

    .. code-block:: yaml

        services:
            twig.extension.your_extension_name:
                class: Nombre\De\Clase\De\La\Extensión\Completamente\Cualificado
                tags:
                        - { name: twig.extension }

    .. code-block:: xml

        <service id="twig.extension.your_extension_name" class="Nombre\De\Clase\De\La\Extensión\Completamente\Cualificado">
            <tag name="twig.extension" />
        </service>

    .. code-block:: php

        $container
            ->register('twig.extension.your_extension_name', 'Nombre\De\Clase\De\La\Extensión\Completamente\Cualificado')
            ->addTag('twig.extension')
        ;

Para información sobre cómo crear la clase extensión de *Twig* real, consulta el tema en la `documentación de extensiones`_.

Antes de escribir tus propias extensiones, echa un vistazo al `Repositorio oficial de extensiones Twig`_ el cual ya cuenta con varias útiles extensiones. Por ejemplo ``Intl`` y su filtro ``localizeddate`` que formatea una fecha según la configuración regional del usuario. Estas extensiones oficiales de *Twig* también se tienen que añadir como servicios normales:

.. configuration-block::

    .. code-block:: yaml

        services:
            twig.extension.intl:
                class: Twig_Extensions_Extension_Intl
                tags:
                        - { name: twig.extension }

    .. code-block:: xml

        <service id="twig.extension.intl" class="Twig_Extensions_Extension_Intl">
            <tag name="twig.extension" />
        </service>

    .. code-block:: php

        $container
            ->register('twig.extension.intl', 'Twig_Extensions_Extension_Intl')
            ->addTag('twig.extension')
        ;

.. _dic-tags-kernel-event-listener:

Habilitando escuchas personalizados
-----------------------------------

Para habilitar un escucha personalizado, añádelo como un servicio regular en uno de tus archivos de configuración, y etiquétalo con ``kernel.event_listener``. Debes proporcionar el nombre del evento a tu servicio escucha, así como el método que deberá invocar:

.. configuration-block::

    .. code-block:: yaml

        services:
            kernel.listener.your_listener_name:
                class: Nombre\De\Clase\Escucha\Completamente\Cualificado
                tags:
                        - { name: kernel.event_listener, event: xxx, method: onXxx }

    .. code-block:: xml

        <service id="kernel.listener.your_listener_name" class="Nombre\De\Clase\Escucha\Completamente\Cualificado">
            <tag name="kernel.event_listener" event="xxx" method="onXxx" />
        </service>

    .. code-block:: php

        $container
            ->register('kernel.listener.your_listener_name', 'Fully\Qualified\Listener\Class\Name')
            ->addTag('kernel.event_listener', array('event' => 'xxx', 'method' => 'onXxx'))
        ;

.. note::

    También puedes especificar la prioridad como un atributo de la etiqueta ``kernel.event_listener`` (al igual que el método o los atributos de eventos), ya sea con un número entero positivo o negativo. Esto te permite asegurarte de que tu escucha siempre se llama antes o después de otro escucha del mismo evento.

Habilitando motores de plantilla personalizados
-----------------------------------------------

Para activar un motor de plantillas personalizado, añádelo como un servicio regular en una de tus configuraciones, etiquétalo con ``templating.engine``:

.. configuration-block::

    .. code-block:: yaml

        services:
            templating.engine.your_engine_name:
                class: Fully\Qualified\Engine\Class\Name
                tags:
                        - { name: templating.engine }

    .. code-block:: xml

        <service id="templating.engine.your_engine_name" class="Fully\Qualified\Engine\Class\Name">
            <tag name="templating.engine" />
        </service>

    .. code-block:: php

        $container
            ->register('templating.engine.your_engine_name', 'Fully\Qualified\Engine\Class\Name')
            ->addTag('templating.engine')
        ;

Habilitando cargadores de enrutado personalizados
-------------------------------------------------

Para habilitar un cargador de enrutado personalizado, añádelo como un servicio regular en tu configuración, y etiquétalo con ``routing.loader``:

.. configuration-block::

    .. code-block:: yaml

        services:
            routing.loader.your_loader_name:
                class: Nombre\De\Clase\Completamente\Cualificado
                tags:
                        - { name: routing.loader }

    .. code-block:: xml

        <service id="routing.loader.your_loader_name" class="Nombre\De\Clase\Completamente\Cualificado">
            <tag name="routing.loader" />
        </service>

    .. code-block:: php

        $container
            ->register('routing.loader.your_loader_name', 'Nombre\De\Clase\Del\Cargador\Completamente\Cualificado')
            ->addTag('routing.loader')
        ;

.. _dic_tags-monolog:

Usando un canal de registro personalizado con ``Monolog``
---------------------------------------------------------

``Monolog`` te permite compartir sus controladores entre varios canales del registro cronológico de eventos.
El servicio de registro cronológico utiliza el canal ``app`` pero puedes cambiar el canal cuando inyectes el registro cronológico en un servicio.

.. configuration-block::

    .. code-block:: yaml

        services:
            my_service:
                class: Nombre\De\Clase\Del\Cargador\Completamente\Cualificado
                arguments: [@logger]
                tags:
                        - { name: monolog.logger, channel: acme }

    .. code-block:: xml

        <service id="my_service" class="Nombre\De\Clase\Del\Cargador\Completamente\Cualificado">
            <argument type="service" id="logger" />
            <tag name="monolog.logger" channel="acme" />
        </service>

    .. code-block:: php

        $definition = new Definition('Nombre\De\Clase\Del\Cargador\Completamente\Cualificado', array(new Reference('logger'));
        $definition->addTag('monolog.logger', array('channel' => 'acme'));
        $container->register('my_service', $definition);;

.. note::

    Esto sólo funciona cuando el servicio del registro cronológico es un argumento del constructor, no cuando se inyecta a través de un definidor.

.. _dic_tags-monolog-processor:

Agregando un procesador para ``Monolog``
----------------------------------------

``Monolog`` te permite agregar procesadores al registro cronológico o a los controladores para añadir datos adicionales en los registros. Un procesador recibe el registro como argumento y lo tiene que devolver después de añadir alguna información adicional en el atributo ``extra`` del registro.

Vamos a ver cómo puedes utilizar el ``IntrospectionProcessor`` integrado para agregar el archivo, la línea, la clase y el método en que se activó el registro cronológico.

Puedes agregar un procesador globalmente:

.. configuration-block::

    .. code-block:: yaml

        services:
            my_service:
                class: Monolog\Processor\IntrospectionProcessor
                tags:
                        - { name: monolog.processor }

    .. code-block:: xml

        <service id="my_service" class="Monolog\Processor\IntrospectionProcessor">
            <tag name="monolog.processor" />
        </service>

    .. code-block:: php

        $definition = new Definition('Monolog\Processor\IntrospectionProcessor');
        $definition->addTag('monolog.processor');
        $container->register('my_service', $definition);

.. tip::

    Si el servicio no es ejecutable (con ``__invoke``) puedes agregar el atributo ``method`` en la etiqueta para utilizar un método específico.

También puedes agregar un procesador para un controlador específico utilizando el atributo ``handler``:

.. configuration-block::

    .. code-block:: yaml

        services:
            my_service:
                class: Monolog\Processor\IntrospectionProcessor
                tags:
                        - { name: monolog.processor, handler: firephp }

    .. code-block:: xml

        <service id="my_service" class="Monolog\Processor\IntrospectionProcessor">
            <tag name="monolog.processor" handler="firephp" />
        </service>

    .. code-block:: php

        $definition = new Definition('Monolog\Processor\IntrospectionProcessor');
        $definition->addTag('monolog.processor', array('handler' => 'firephp');
        $container->register('my_service', $definition);

También puedes agregar un procesador para un canal del registro cronológico específico usando el atributo ``channel``. Esto registrará el procesador únicamente para el canal de registro cronológico de ``security`` utilizado en el componente de seguridad:

.. configuration-block::

    .. code-block:: yaml

        services:
            my_service:
                class: Monolog\Processor\IntrospectionProcessor
                tags:
                        - { name: monolog.processor, channel: security }

    .. code-block:: xml

        <service id="my_service" class="Monolog\Processor\IntrospectionProcessor">
            <tag name="monolog.processor" channel="security" />
        </service>

    .. code-block:: php

        $definition = new Definition('Monolog\Processor\IntrospectionProcessor');
        $definition->addTag('monolog.processor', array('channel' => 'security');
        $container->register('my_service', $definition);

.. note::

    No puedes utilizar ambos atributos ``handler`` y ``channel`` para la misma etiqueta debido a que los controladores se comparten entre todos los canales.

..  _`documentación de extensiones`: http://gitnacho.github.com/Twig/extensions.html
..  _`Repositorio oficial de extensiones Twig`: http://github.com/fabpot/Twig-extensions
