Almacenando en caché
====================

El paquete ``BlockBundle`` integra con el `SonataCacheBundle <https://github.com/sonata-project/SonataCacheBundle>`_ para proporcionar varias soluciones de almacenamiento en caché. Dale un vistazo a los adaptadores disponibles en el ``SonataCacheBundle`` para ver todas las opciones.

El ``BlockBundle`` además proporciona sus propios adaptadores para:

* `ESI <http://wikipedia.org/wiki/Edge_Side_Includes>`_
* `SSI <http://wikipedia.org/wiki/Server_Side_Includes>`_
* Javascript asíncrono
* Javascript sincrónico

.. note::

  Es aconsejable almacenar todas las opciones en el bloque documento al utilizar la memoria caché.

Dependencias
------------

The cache functionality is optional and depends on the `SonataCacheBundle <https://github.com/sonata-project/SonataCacheBundle>`_.

Instalando
----------

The installation is split between the SonataCacheBundle, the SymfonyCmfBlockBundle and the SonataBlockBundle:

1. *SonataCacheBundle* - Follow the installation instructions from the `SonataCacheBundle documentation <http://sonata-project.org/bundles/cache/master/doc/index.html>`_.
2. *SymfonyCmfBlockBundle* - At the end of your routing file, add the following lines:

  .. configuration-block::

      .. code-block:: yaml

          # app/config/routing.yml
          # ...
          # routes SymfonyCmfBlockBundle cache adapters
          block_cache:
              resource: "@SymfonyCmfBlockBundle/Resources/config/routing/cache.xml"
              prefix: /

3. *SonataBlockBundle* - Use the ``sonata_block`` key to configure the cache adapter for each block service.

  .. configuration-block::

      .. code-block:: yaml

          # app/config/config.yml
          sonata_block:
          # ...
              blocks:
                  symfony_cmf.block.action:
                      # Usa el id del adaptador del servicio cache 
                      cache: symfony_cmf.block.cache.js_async

Flujo de trabajo
----------------

Lo siguiente sucede al dibujar un bloque la memoria caché:

* se carga un documento basándose en el nombre
* si está configurada la memorización en caché, se revisa la caché y si se encuentra el contenido se devuelve
*

  * las claves de la caché se componen utilizando:

    * the cache keys of the block service
    * the extraCacheKeys passed from the template

  * the cache adapter is asked for a cache element

    * the ESI and SSI adapter add a specific tag and a url to retrieve the block content
    * the Javascript adapter adds javascript and a url to retrieve the block content

  * if the cache element is not expired and has data it is returned
* the template is rendered:

  * for ESI and SSI the url is called to retrieve the block content
  * for Javascript the browser calls a url and replaces a placeholder with the returned block content

.. note::

    The additional cache adapters of the BlockBundle always return that the cache is found, have a look at the ``has``
    method of the adapters in the SonataCacheBundle to see how they respond.

If cache is checked and the cache adapter returned that no cache was found, the workflow proceeds like this:

* each block document also has a block service, the execute method of it is called to render the block and return a response
* if the response is cacheable the configured adapter creates a cache element, it contains

  * the computed cache keys
  * the ttl of the response
  * the response
  * and additional contextual keys

* the template is rendered

Cache keys
----------

The block service has the responsibility to generate the cache keys, the method ``getCacheKeys`` returns these keys, see
:ref:`block-service`.

The block services shipped with the BlockBunde use the ``getCacheKeys`` method of the ``Sonata\BlockBundle\Block\BaseBlockService``,
and return:

* block_id
* updated_at

.. note::

    If block settings need to be persisted between requests it is advised to store them in the block document. Alternatively
    they can be added to the cache keys. However be very cautious because, depending on the adapter, the cache keys can be
    send to the browser and are not secure.

Extra cache keys
~~~~~~~~~~~~~~~~

The extra cache keys array is used to store metadata along the cache element. The metadata can be used to invalidate a
set of cache elements.

Contextual keys
~~~~~~~~~~~~~~~

The contextual cache array hold the object class and id used inside the template. This contextual cache array is then
added to the extra cache key.

This feature can be use like this ``$cacheManager->remove(array('objectId' => 'id'))``.

Of course not all cache adapters support this feature, varnish and mongodb do.

The BlockBundle also has a cache invalidation listener that calls the ``flush`` method of a cache adapter automatically
when a cached block document is updated or removed.

Dibujando el bloque
-------------------

The following parameters can be used in the ``sonata_block_render`` code in your Twig template when using cache:

* **useCache**: use the configured cache for a block (*default*: true)
* **extraCachekeys**: expects an array with extra cache keys (*default*: empty array)

.. code-block:: jinja

    {{ sonata_block_render(
        { 'name': 'rssBlock' },
        true,
        { 'extra_key': 'my_block' }
    ) }}

Adaptadores
-----------

*ESI*
~~~~~

This extends the default EsiCache adapter of the SonataCacheBundle.

Configurando
""""""""""""

.. configuration-block::

    .. code-block:: yaml

        # app/config/config.yml
        symfony_cmf_block:
            # ...
            caches:
                esi:
                    token: a unique security key # a random one is generated by default
                    servers:
                        - varnishadm -T 127.0.0.1:2000 {{ COMMAND }} "{{ EXPRESSION }}"

SSI
~~~

This extends the default SsiCache adapter of the SonataCacheBundle.

Configurando
""""""""""""

.. configuration-block::

    .. code-block:: yaml

        # app/config/config.yml
        symfony_cmf_block:
            # ...
            caches:
                ssi:
                   token: una clave de seguridad única # de manera predeterminada se genera una aleatoria

*JavaScript*
~~~~~~~~~~~~

Renders the block using javascript, the page is loaded and not waiting for the block to be finished rendering or
retrieving data. The block is then asynchronously or synchronously loaded and added to the page.