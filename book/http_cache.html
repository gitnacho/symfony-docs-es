
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Caché HTTP &mdash; Manual de Symfony2 en Español</title>
    
    <link rel="stylesheet" href="../_static/tnp.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.14',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/icotnp.ico"/>
    <link rel="top" title="Manual de Symfony2 en Español" href="../index.html" />
    <link rel="up" title="Libro" href="index.html" />
    <link rel="next" title="Traduciendo" href="translation.html" />
    <link rel="prev" title="Seguridad" href="security.html" /> 
  </head>
  <body>
  <div class="imalogo">
    
  <a href="../index.html"><img src="http://gitnacho.github.com/tnp/img/sf/logo-big.gif" alt="Edición estándar de Symfony2" />
  
    <a href="http://gitnacho.github.com/tnp/"><img src="http://gitnacho.github.com/tnp/_static/normaltnp.png" alt="Traducciones de Nacho Pacheco" /></a>
    <div class="social">
      <a href="https://twitter.com/share" class="twitter-share-button" data-via="esymfony" data-lang="es">Tweet</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    </div>
    <div id="searchbox">
      <form class="searc " action="../search.html" method="get">
      <input type="search" name="q" placeholder="Término a buscar" />
      <input type="submit" value="Ir" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
    

    
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="translation.html" title="Traduciendo"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="security.html" title="Seguridad"
             accesskey="P">anterior</a> |</li>
        <li><a href="../index.html">en Español</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Libro</a> &raquo;</li> 
      </ul>
    </div>
  </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cache-http">
<span id="index-0"></span><h1>Caché <em>HTTP</em><a class="headerlink" href="#cache-http" title="Enlazar permanentemente con este título">¶</a></h1>
<p>La naturaleza de las aplicaciones web ricas significa que son dinámicas. No importa qué tan eficiente sea tu aplicación, cada petición siempre contendrá más sobrecarga que servir un archivo estático.</p>
<p>Y para la mayoría de las aplicaciones Web, está bien. <em>Symfony2</em> es tan rápido como el rayo, a menos que estés haciendo una muy complicada aplicación, cada petición se responderá rápidamente sin poner demasiada tensión a tu servidor.</p>
<p>Pero cuando tu sitio crezca, la sobrecarga general se puede convertir en un problema. El procesamiento que se realiza normalmente en cada petición se debe hacer sólo una vez. Este exactamente es el objetivo que tiene que consumar la memoria caché.</p>
<div class="section" id="la-memoria-cache-en-hombros-de-gigantes">
<h2>La memoria caché en hombros de gigantes<a class="headerlink" href="#la-memoria-cache-en-hombros-de-gigantes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La manera más efectiva para mejorar el rendimiento de una aplicación es memorizar en caché la salida completa de una página y luego eludir por completo la aplicación en cada petición posterior. Por supuesto, esto no siempre es posible para los sitios web altamente dinámicos, ¿o no? En este capítulo, te mostraremos cómo funciona el sistema de caché <em>Symfony2</em> y por qué pensamos que este es el mejor enfoque posible.</p>
<p>El sistema de cache <em>Symfony2</em> es diferente porque se basa en la simplicidad y el poder de la caché <em>HTTP</em> tal como está definido en la <a class="reference internal" href="../glossary.html#term-especificacion-http"><em class="xref std std-term">especificación HTTP</em></a>.
En lugar de reinventar una metodología de memoria caché, <em>Symfony2</em> adopta la norma que define la comunicación básica en la Web. Una vez que comprendas los principios fundamentales de los modelos de caducidad y validación de la memoria caché <em>HTTP</em>, estarás listo para dominar el sistema de caché <em>Symfony2</em>.</p>
<p>Para efectos de aprender cómo guardar en caché con <em>Symfony2</em>, vamos a cubrir el tema en cuatro pasos:</p>
<ul class="simple">
<li><strong>Paso 1</strong>: Una <a class="reference internal" href="#gateway-caches"><em>pasarela de caché</em></a>, o delegado inverso, es una capa independiente situada frente a tu aplicación. La caché del delegado inverso responde a medida que son devueltas desde tu aplicación y responde a peticiones con respuestas de la caché antes de que lleguen a tu aplicación. <em>Symfony2</em> proporciona su propio delegado inverso, pero puedes utilizar cualquier delegado inverso.</li>
<li><strong>Paso 2</strong>: <a class="reference internal" href="#http-cache-introduction"><em>cache HTTP</em></a> las cabeceras se utilizan para comunicarse con la pasarela de caché y cualquier otra caché entre la aplicación y el cliente. <em>Symfony2</em> proporciona parámetros predeterminados y una potente interfaz para interactuar con las cabeceras de caché.</li>
<li><strong>Paso 3</strong>: <em>HTTP</em> <a class="reference internal" href="#http-expiration-validation"><em>caducidad y validación</em></a> son los dos modelos utilizados para determinar si el contenido memorizado en caché es <em>fresco</em> (se puede reutilizar de la memoria caché) u <em>obsoleto</em> (lo debe regenerar la aplicación).</li>
<li><strong>Paso 4</strong>: <a class="reference internal" href="#edge-side-includes"><em>Inclusión del borde lateral</em></a> (Edge Side Includes -<em>ESI</em>) permite que la caché <em>HTTP</em> utilice fragmentos de la página en caché (incluso fragmentos anidados) independientemente.
Con <em>ESI</em>, incluso puedes guardar en caché una página entera durante 60 minutos, pero una barra lateral integrada sólo por 5 minutos.</li>
</ul>
<p>Dado que la memoria caché <em>HTTP</em> no es exclusiva de <em>Symfony</em>, ya existen muchos artículos sobre el tema. Si eres nuevo para la memoria caché <em>HTTP</em>, te <em>recomendamos</em> el artículo de Ryan Tomayko <a class="reference external" href="http://tomayko.com/writings/things-caches-do">Things Caches Do</a>. Otro recurso en profundidad es la <a class="reference external" href="http://www.mnot.net/cache_docs/">Guía de caché</a> de Mark Nottingham.</p>
</div>
<div class="section" id="memoria-cache-con-pasarela-de-cache">
<span id="gateway-caches"></span><span id="index-1"></span><h2>Memoria caché con pasarela de caché<a class="headerlink" href="#memoria-cache-con-pasarela-de-cache" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Cuándo memorizar caché con <em>HTTP</em>, la <em>caché</em> está separada de tu aplicación por completo y se sitúa entre tu aplicación y el cliente haciendo la petición.</p>
<p>El trabajo de la caché es aceptar las peticiones del cliente y pasarlas de nuevo a tu aplicación. La memoria caché también recibirá las respuestas devueltas por tu aplicación y las remitirá al cliente. La caché es el &#8220;geniecillo&#8221; de la comunicación petición-respuesta entre el cliente y tu aplicación.</p>
<p>En el camino, la memoria caché almacena cada respuesta que se considere &#8220;cacheable&#8221; (consulta <a class="reference internal" href="#http-cache-introduction"><em>Introducción a la memoria caché HTTP</em></a>). Si de nuevo se solicita el mismo recurso, la memoria caché envía la respuesta memorizada en caché al cliente, eludiendo tu aplicación por completo.</p>
<p>Este tipo de caché se conoce como pasarela de caché <em>HTTP</em> y existen muchas como <a class="reference external" href="http://www.varnish-cache.org/">Varnish</a>, <a class="reference external" href="http://wiki.squid-cache.org/SquidFaq/ReverseProxy">Squid en modo delegado inverso</a> y el delegado inverso de <em>Symfony2</em>.</p>
<div class="section" id="tipos-de-cache">
<span id="index-2"></span><h3>Tipos de Caché<a class="headerlink" href="#tipos-de-cache" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Sin embargo, una pasarela de caché no es el único tipo de caché. De hecho, las cabeceras de caché <em>HTTP</em> enviadas por tu aplicación son consumidas e interpretadas por un máximo de tres diferentes tipos de caché:</p>
<ul class="simple">
<li><em>Caché de navegadores</em>: Cada navegador viene con su propia caché local que es realmente útil para cuando pulsas &#8220;atrás&#8221; o en imágenes y otros activos.
La caché del navegador es una caché <em>privada</em>, los recursos memorizados en caché no se comparten con nadie más.</li>
<li><em>Delegados de caché</em>: Un delegado de memoria caché <em>compartida</em> es aquel en el cual muchas personas pueden estar detrás de uno solo. Por lo general instalada por las grandes corporaciones y proveedores de Internet para reducir latencia y tráfico de red.</li>
<li><em>Pasarela de caché</em>: Al igual que un delegado, también es una memoria caché <em>compartida</em> pero en el lado del servidor. Instalada por los administradores de red, esta tiene sitios web más escalables, confiables y prácticos.</li>
</ul>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">Las pasarelas de caché a veces también se conocen como delegados inversos de caché, cachés alquiladas o incluso aceleradores <em>HTTP</em>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">La importancia de la caché <em>privada</em> frente a la <em>compartida</em> será más evidente a medida que hablemos de las respuestas en la memoria caché con contenido que es específico para un solo usuario (por ejemplo, información de cuenta).</p>
</div>
<p>Cada respuesta de tu aplicación probablemente vaya a través de uno o los dos primeros tipos de caché. Estas cachés están fuera de tu control, pero siguen las instrucciones de caché <em>HTTP</em> establecidas en la respuesta.</p>
</div>
<div class="section" id="delegado-inverso-de-symfony2">
<span id="symfony-gateway-cache"></span><span id="index-3"></span><h3>Delegado inverso de <em>Symfony2</em><a class="headerlink" href="#delegado-inverso-de-symfony2" title="Enlazar permanentemente con este título">¶</a></h3>
<p><em>Symfony2</em> viene con un delegado inverso de caché (también conocido como pasarela de caché) escrito en <em>PHP</em>. Que al activarla, inmediatamente puede memorizar en caché respuestas de tu aplicación. La instalación es muy fácil. Cada nueva aplicación <em>Symfony2</em> viene con una caché preconfigurada en el núcleo (<tt class="docutils literal"><span class="pre">AppCache</span></tt>) que envuelve al predeterminado (<tt class="docutils literal"><span class="pre">AppKernel</span></tt>). La memoria caché del núcleo <em>es</em> el delegado inverso.</p>
<p>Para habilitar la memoria caché, modifica el código de un controlador frontal para utilizar la caché del núcleo:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// web/app.php</span>

<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../app/bootstrap.php.cache&#39;</span><span class="p">;</span>
<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../app/AppKernel.php&#39;</span><span class="p">;</span>
<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../app/AppCache.php&#39;</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Request</span><span class="p">;</span>

<span class="nv">$kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppKernel</span><span class="p">(</span><span class="s1">&#39;prod&#39;</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">loadClassCache</span><span class="p">();</span>
<span class="c1">// envuelve el AppKernel predeterminado con un AppCache</span>
<span class="nv">$kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppCache</span><span class="p">(</span><span class="nv">$kernel</span><span class="p">);</span>
<span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">handle</span><span class="p">(</span><span class="nx">Request</span><span class="o">::</span><span class="na">createFromGlobals</span><span class="p">())</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
<p>La memoria caché del núcleo actúa de inmediato como un delegado inverso &#8212;memorizando en caché las respuestas de tu aplicación y devolviéndolas al cliente.</p>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p>La caché del núcleo tiene un método especial <cite>getLog()</cite>, el cual devuelve una cadena que representa lo que sucedió en la capa de la caché. En el entorno de desarrollo, se usa para depurar y validar la estrategia de caché:</p>
<div class="last highlight-php"><div class="highlight"><pre><span class="nb">error_log</span><span class="p">(</span><span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">getLog</span><span class="p">());</span>
</pre></div>
</div>
</div>
<p>El objeto <tt class="docutils literal"><span class="pre">AppCache</span></tt> tiene una configuración predeterminada sensible, pero la puedes afinar por medio de un conjunto de opciones que puedes configurar sustituyendo el método <tt class="docutils literal"><span class="pre">getOptions()</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/AppCache.php</span>

<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AppCache</span> <span class="k">extends</span> <span class="nx">HttpCache</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">getOptions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;debug&#39;</span>                  <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
            <span class="s1">&#39;default_ttl&#39;</span>            <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;private_headers&#39;</span>        <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;Authorization&#39;</span><span class="p">,</span> <span class="s1">&#39;Cookie&#39;</span><span class="p">),</span>
            <span class="s1">&#39;allow_reload&#39;</span>           <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
            <span class="s1">&#39;allow_revalidate&#39;</span>       <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
            <span class="s1">&#39;stale_while_revalidate&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;stale_if_error&#39;</span>         <span class="o">=&gt;</span> <span class="mi">60</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">A menos que la sustituyas en <tt class="docutils literal"><span class="pre">getOptions()</span></tt>, la opción <tt class="docutils literal"><span class="pre">debug</span></tt> se establecerá automáticamente al valor de depuración del <tt class="docutils literal"><span class="pre">AppKernel</span></tt> envuelto.</p>
</div>
<p>Aquí está una lista de las principales opciones:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">default_ttl</span></tt>: El número de segundos que una entrada de caché se debe considerar nueva cuando no hay información fresca proporcionada explícitamente en una respuesta. Las cabeceras explícitas <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> o <tt class="docutils literal"><span class="pre">Expires</span></tt> sustituyen este valor (predeterminado: <tt class="docutils literal"><span class="pre">0</span></tt>);</li>
<li><tt class="docutils literal"><span class="pre">private_headers</span></tt>: Conjunto de cabeceras de la petición que desencadenan el comportamiento <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> &#8220;privado&#8221; en las respuestas en que la respuesta explícitamente no es <tt class="docutils literal"><span class="pre">pública</span></tt> o <tt class="docutils literal"><span class="pre">privada</span></tt> vía una directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>.
(default: <tt class="docutils literal"><span class="pre">Authorization</span></tt> y <em class="dfn">cookie</em>);</li>
<li><tt class="docutils literal"><span class="pre">allow_reload</span></tt>: Especifica si el cliente puede forzar una recarga desde caché incluyendo una directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> <tt class="docutils literal"><span class="pre">&quot;no-cache&quot;</span></tt> en la petición. Selecciona <tt class="docutils literal"><span class="pre">true</span></tt> para cumplir con la RFC 2616 (por omisión: <tt class="docutils literal"><span class="pre">false</span></tt>);</li>
<li><tt class="docutils literal"><span class="pre">allow_revalidate</span></tt>: Especifica si el cliente puede forzar una revalidación de caché incluyendo una directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> <tt class="docutils literal"><span class="pre">max-age</span> <span class="pre">=</span> <span class="pre">0</span></tt> en la petición. Ponla en <tt class="docutils literal"><span class="pre">true</span></tt> para cumplir con la RFC 2616 (por omisión: false);</li>
<li><tt class="docutils literal"><span class="pre">stale_while_revalidate</span></tt>: Especifica el número de segundos predeterminado (la granularidad es el segundo puesto que la precisión de respuesta <em>TTL</em> es un segundo) durante el cual la memoria caché puede regresar inmediatamente una respuesta obsoleta mientras que revalida en segundo plano (por omisión: <tt class="docutils literal"><span class="pre">2</span></tt>); este ajuste lo reemplaza <tt class="docutils literal"><span class="pre">stale-while-revalidate</span></tt> de la extensión <em>HTTP</em> <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> (consulta la <em>RFC 5.861</em>);</li>
<li><tt class="docutils literal"><span class="pre">stale_if_error</span></tt>: Especifica el número de segundos predeterminado (la granularidad es el segundo) durante el cual la caché puede servir una respuesta obsoleta cuando se detecta un error (por omisión: <tt class="docutils literal"><span class="pre">60</span></tt>). Este valor lo reemplaza <tt class="docutils literal"><span class="pre">stale-if-error</span></tt> de la extensión <em>HTTP</em> <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> (consulta la RFC 5861).</li>
</ul>
<p>Si <tt class="docutils literal"><span class="pre">debug</span></tt> es <tt class="docutils literal"><span class="pre">true</span></tt>, <em>Symfony2</em> automáticamente agrega una cabecera <tt class="docutils literal"><span class="pre">X-Symfony-Cache</span></tt> a la respuesta que contiene información útil acerca de aciertos y errores de caché.</p>
<div class="sidebar">
<p class="first sidebar-title">Cambiando de un delegado inverso a otro</p>
<p>El delegado inverso de <em>Symfony2</em> es una gran herramienta a utilizar en el desarrollo de tu sitio web o al desplegar tu web en un servidor compartido donde no puedes instalar nada más allá que código <em>PHP</em>. Pero está escrito en <em>PHP</em>, no puede ser tan rápido como un delegado escrito en C. Es por eso que recomendamos -de ser posible- usar <em>Varnish</em> o <em>Squid</em> en tus servidores de producción. La buena nueva es que el cambio de un servidor delegado a otro es fácil y transparente, sin modificar el código necesario en tu aplicación. Comienza fácilmente con el delegado inverso de <em>Symfony2</em> y actualiza a <em>Varnish</em> cuando aumente el tráfico.</p>
<p class="last">Para más información sobre el uso de <em>Varnish</em> con <em>Symfony2</em>, consulta el capítulo <a class="reference internal" href="../cookbook/cache/varnish.html"><em>Cómo usar Varnish</em></a> del recetario.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">El rendimiento del delegado inverso de <em>Symfony2</em> es independiente de la complejidad de tu aplicación. Eso es porque el núcleo de tu aplicación sólo se inicia cuando la petición se debe remitir a ella.</p>
</div>
</div>
</div>
<div class="section" id="introduccion-a-la-memoria-cache-http">
<span id="http-cache-introduction"></span><span id="index-4"></span><h2>Introducción a la memoria caché <em>HTTP</em><a class="headerlink" href="#introduccion-a-la-memoria-cache-http" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para aprovechar las ventajas de las capas de memoria caché disponibles, tu aplicación se debe poder comunicar con las respuestas que son memorizables y las reglas que rigen cuándo y cómo la caché será obsoleta. Esto se hace ajustando las cabeceras de caché <em>HTTP</em> en la respuesta.</p>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">Ten en cuenta que <em>&#8220;HTTP&#8221;</em> no es más que el lenguaje (un lenguaje de texto simple) que los clientes web (navegadores, por ejemplo) y los servidores web utilizan para comunicarse entre sí. Cuando hablamos de la memoria caché <em>HTTP</em>, estamos hablando de la parte de ese lenguaje que permite a los clientes y servidores intercambiar información relacionada con la memoria caché.</p>
</div>
<p><em>HTTP</em> especifica cuatro cabeceras de caché para respuestas en las que estamos interesados:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Cache-Control</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Expires</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ETag</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Last-Modified</span></tt></li>
</ul>
<p>La cabecera más importante y versátil es la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>, la cual en realidad es una colección de variada información de caché.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Cada una de las cabeceras se explica en detalle en la sección <a class="reference internal" href="#http-expiration-validation"><em>Caducidad y validación HTTP</em></a>.</p>
</div>
<div class="section" id="la-cabecera-cache-control">
<span id="index-5"></span><h3>La cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt><a class="headerlink" href="#la-cabecera-cache-control" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> es la única que no contiene una, sino varias piezas de información sobre la memoria caché de una respuesta. Cada pieza de información está separada por una coma:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">Cache</span><span class="o">-</span><span class="nx">Control</span><span class="o">:</span> <span class="k">private</span><span class="p">,</span> <span class="nb">max</span><span class="o">-</span><span class="nx">age</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nx">must</span><span class="o">-</span><span class="nx">revalidate</span>

<span class="nx">Cache</span><span class="o">-</span><span class="nx">Control</span><span class="o">:</span> <span class="nb">max</span><span class="o">-</span><span class="nx">age</span><span class="o">=</span><span class="mi">3600</span><span class="p">,</span> <span class="nx">must</span><span class="o">-</span><span class="nx">revalidate</span>
</pre></div>
</div>
<p><em>Symfony</em> proporciona una abstracción de la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> para hacer más manejable su creación:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>

<span class="c1">// marca la respuesta como pública o privada</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setPublic</span><span class="p">();</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setPrivate</span><span class="p">();</span>

<span class="c1">// fija la edad máxima de privado o compartido</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>

<span class="c1">// fija una directiva Cache-Control personalizada</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">addCacheControlDirective</span><span class="p">(</span><span class="s1">&#39;must-revalidate&#39;</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="respuestas-publicas-frente-a-privadas">
<h3>Respuestas públicas frente a privadas<a class="headerlink" href="#respuestas-publicas-frente-a-privadas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ambas, la pasarela de caché y el delegado de caché, son considerados como cachés &#8220;compartidas&#8221; debido a que el contenido memorizado en caché lo comparten más de un usuario. Si cada vez equivocadamente una memoria caché compartida almacena una respuesta específica al usuario, posteriormente la puede devolver a cualquier cantidad de usuarios diferentes. ¡Imagina si la información de tu cuenta se memoriza en caché y luego la regresa a todos los usuarios posteriores que soliciten la página de su cuenta!</p>
<p>Para manejar esta situación, cada respuesta se puede fijar para que sea pública o privada:</p>
<ul class="simple">
<li><em>public</em>: Indica que la respuesta se puede memorizar en caché por ambas cachés privadas y compartidas;</li>
<li><em>private</em>: Indica que la totalidad o parte del mensaje de la respuesta es para un solo usuario y no se debe memorizar en caché en una caché compartida.</li>
</ul>
<p>Por omisión, <em>Symfony</em> conservadoramente fija cada respuesta para que sea privada. Para aprovechar las ventajas de las cachés compartidas (como el delegado inverso de <em>Symfony2</em>), explícitamente deberás fijar la respuesta como pública.</p>
</div>
<div class="section" id="metodos-seguros">
<span id="index-6"></span><h3>Métodos seguros<a class="headerlink" href="#metodos-seguros" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La memoria caché <em>HTTP</em> sólo funciona para métodos <em>HTTP</em> &#8220;seguros&#8221; (como <em>GET</em> y <em>HEAD</em>). Estar seguro significa que nunca cambia de estado la aplicación en el servidor al servir la petición (por supuesto puedes registrar información, datos de la caché, etc.)
Esto tiene dos consecuencias muy razonables:</p>
<ul class="simple">
<li><em>Nunca</em> debes cambiar el estado de tu aplicación al responder a una petición <em>GET</em> o <em>HEAD</em>. Incluso si no utilizas una pasarela caché, la presencia del delegado de caché significa que alguna petición <em>GET</em> o <em>HEAD</em> puede o no llegar a tu servidor.</li>
<li>No supongas que hay métodos <em>PUT</em>, <em>POST</em> o DELETE en caché. Estos métodos están diseñados para utilizarse al mutar el estado de tu aplicación (por ejemplo, borrar una entrada de <em>blog</em>). La memoria caché debe impedir que determinadas peticiones toquen y muten tu aplicación.</li>
</ul>
</div>
<div class="section" id="reglas-de-cache-y-valores-predeterminados">
<h3>Reglas de caché y valores predeterminados<a class="headerlink" href="#reglas-de-cache-y-valores-predeterminados" title="Enlazar permanentemente con este título">¶</a></h3>
<p><em>HTTP</em> 1.1 por omisión, permite a cualquiera memorizar en caché a menos que haya una cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> explícita. En la práctica, la mayoría de cachés no hacen nada cuando solicitan una <tt class="docutils literal"><span class="pre">galleta</span></tt>, una cabecera de autorización, utilizar un método no seguro (es decir, <em>PUT</em>, <em>POST</em>, DELETE), o cuando las respuestas tienen código de redirección de estado.</p>
<p><em>Symfony2</em> automáticamente establece una sensible y conservadora cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> cuando esta no está definida por el desarrollador, siguiendo estas reglas:</p>
<ul class="simple">
<li>Si no has definido cabecera caché (<tt class="docutils literal"><span class="pre">Cache-Control</span></tt>, <tt class="docutils literal"><span class="pre">Expires</span></tt>,  <tt class="docutils literal"><span class="pre">ETag</span></tt> o <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>), <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> es establecida en <tt class="docutils literal"><span class="pre">no-cache</span></tt>, lo cual significa que la respuesta no se guarda en caché;</li>
<li>Si <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> está vacía (pero una de las otras cabeceras de caché está presente), su valor se establece en <tt class="docutils literal"><span class="pre">private,</span> <span class="pre">must-revalidate</span></tt>;</li>
<li>Pero si por lo menos una  directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> está establecida, y no se han añadido directivas <tt class="docutils literal"><span class="pre">public</span></tt> o <tt class="docutils literal"><span class="pre">private</span></tt> de forma explícita, <em>Symfony2</em> agrega la directiva <tt class="docutils literal"><span class="pre">private</span></tt> automáticamente (excepto cuando <tt class="docutils literal"><span class="pre">s-maxage</span></tt> está establecida).</li>
</ul>
</div>
</div>
<div class="section" id="caducidad-y-validacion-http">
<span id="http-expiration-validation"></span><h2>Caducidad y validación <em>HTTP</em><a class="headerlink" href="#caducidad-y-validacion-http" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La especificación <em>HTTP</em> define dos modelos de memoria caché:</p>
<ul class="simple">
<li>Con el <a class="reference external" href="http://tools.ietf.org/html/rfc2616#section-13.2">modelo de caducidad</a>, sólo tienes que especificar el tiempo en que la respuesta se debe considerar &#8220;fresca&#8221; incluyendo una cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> y/o una <tt class="docutils literal"><span class="pre">Expires</span></tt>. Las cachés que entienden de expiración no harán la misma petición hasta que la versión en caché llegue a su fecha de caducidad y se convierta en &#8220;obsoleta&#8221;.</li>
<li>Cuando las páginas realmente son dinámicas (es decir, su representación cambia con mucha frecuencia), a menudo es necesario el <a class="reference external" href="http://tools.ietf.org/html/rfc2616#section-13.3">modelo de validación</a>. Con este modelo, la memoria caché memoriza la respuesta, pero, pregunta al servidor en cada petición si la respuesta memorizada sigue siendo válida. La aplicación utiliza un identificador de respuesta único (la cabecera <tt class="docutils literal"><span class="pre">Etag</span></tt>) y/o una marca de tiempo (la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>) para comprobar si la página ha cambiado desde su memorización en caché.</li>
</ul>
<p>El objetivo de ambos modelos es nunca generar la misma respuesta en dos ocasiones dependiendo de una caché para almacenar y devolver respuestas <tt class="docutils literal"><span class="pre">&quot;fresco&quot;</span></tt>.</p>
<div class="sidebar">
<p class="first sidebar-title">Leyendo la especificación <em>HTTP</em></p>
<p>La especificación <em>HTTP</em> define un lenguaje sencillo pero potente en el cual clientes y servidores se pueden comunicar. Como desarrollador web, el modelo petición-respuesta de la especificación domina nuestro trabajo. Lamentablemente, el documento de la especificación real &#8212;<a class="reference external" href="http://tools.ietf.org/html/rfc2616">RFC 2616</a>&#8212; puede ser difícil de leer.</p>
<p>Hay un esfuerzo en curso (<a class="reference external" href="http://tools.ietf.org/wg/httpbis/">HTTP Bis</a>) para reescribir la RFC 2616. Este no describe una nueva versión de <em>HTTP</em>, sino sobre todo aclara la especificación <em>HTTP</em> original. La organización también se ha mejorado ya que la especificación se divide en siete partes; todo lo relacionado con la caché <em>HTTP</em> se puede encontrar en dos partes dedicadas (<a class="reference external" href="http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-12">P4 - Petición condicional</a> y <a class="reference external" href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-12">P6 - Caché: Navegador y caché intermedia</a>).</p>
<p class="last">Como desarrollador web, te invitamos a leer la especificación. Su claridad y poder &#8212;incluso más de diez años después de su creación&#8212; tiene un valor incalculable. No te desanimes por la apariencia de la especificación &#8212;su contenido es mucho más bello que la cubierta.</p>
</div>
<div class="section" id="caducidad">
<span id="index-7"></span><h3>Caducidad<a class="headerlink" href="#caducidad" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El modelo de caducidad es el más eficiente y simple de los dos modelos de memoria caché y se debe utilizar siempre que sea posible. Cuando una respuesta se memoriza en caché con una caducidad, la caché memorizará la respuesta y la enviará directamente sin tocar a la aplicación hasta que esta caduque.</p>
<p>El modelo de caducidad se puede lograr usando una de dos, casi idénticas, cabeceras <em>HTTP</em>: <tt class="docutils literal"><span class="pre">Expires</span></tt> o <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>.</p>
</div>
<div class="section" id="caducidad-con-la-cabecera-expires">
<span id="index-8"></span><h3>Caducidad con la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt><a class="headerlink" href="#caducidad-con-la-cabecera-expires" title="Enlazar permanentemente con este título">¶</a></h3>
<p>De acuerdo con la especificación <em>HTTP</em> &#8220;el campo de la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt> da la fecha/hora después de la cual se considera que la respuesta es vieja&#8221;. La cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt> se puede establecer con el método <tt class="docutils literal"><span class="pre">setExpires()</span></tt> de la <tt class="docutils literal"><span class="pre">Respuesta</span></tt>. Esta necesita una instancia de <tt class="docutils literal"><span class="pre">DateTime</span></tt> como argumento:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$fecha</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DateTime</span><span class="p">();</span>
<span class="nv">$date</span><span class="o">-&gt;</span><span class="na">modify</span><span class="p">(</span><span class="s1">&#39;+600 seconds&#39;</span><span class="p">);</span>

<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setExpires</span><span class="p">(</span><span class="nv">$date</span><span class="p">);</span>
</pre></div>
</div>
<p>El resultado de la cabecera <em>HTTP</em> se verá así:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">Expires</span><span class="o">:</span> <span class="nx">Thu</span><span class="p">,</span> <span class="mo">01</span> <span class="nx">Mar</span> <span class="mi">2011</span> <span class="mi">16</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span> <span class="nx">GMT</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">El método <tt class="docutils literal"><span class="pre">setExpires()</span></tt> automáticamente convierte la fecha a la zona horaria GMT como lo requiere la especificación.</p>
</div>
<p>Ten en cuanta que en las versiones de <em>HTTP</em> anteriores a la 1.1 el servidor origen no estaba obligado a enviar la cabecera <tt class="docutils literal"><span class="pre">Date</span></tt>. En consecuencia, la memoria caché (por ejemplo el navegador) podría
necesitar de contar en su reloj local para evaluar la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt> tomando el cálculo de la vida vulnerable para desviaciones del reloj. Otra limitación de la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt> es que la especificación establece que &#8220;Los servidores HTTP/1.1 no deben enviar fechas de <tt class="docutils literal"><span class="pre">Expires</span></tt> de más de un año en el futuro&#8221;.</p>
</div>
<div class="section" id="caducidad-con-la-cabecera-cache-control">
<span id="index-9"></span><h3>Caducidad con la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt><a class="headerlink" href="#caducidad-con-la-cabecera-cache-control" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Debido a las limitaciones de la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt>, la mayor parte del tiempo, debes usar la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> en su lugar. Recordemos que la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> se utiliza para especificar muchas directivas de caché diferentes. Para caducidad, hay dos directivas, <tt class="docutils literal"><span class="pre">max-age</span></tt> y <tt class="docutils literal"><span class="pre">s-maxage</span></tt>. La primera la utilizan todas las cachés, mientras que la segunda sólo se tiene en cuenta por las cachés compartidas:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Establece el número de segundos después de que la</span>
<span class="c1">// respuesta ya no se debe considerar fresca</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>

<span class="c1">// Lo mismo que la anterior pero sólo para cachés compartidas</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
</pre></div>
</div>
<p>La cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> debería tener el siguiente formato (el cual puede tener directivas adicionales):</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">Cache</span><span class="o">-</span><span class="nx">Control</span><span class="o">:</span> <span class="nb">max</span><span class="o">-</span><span class="nx">age</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="nx">s</span><span class="o">-</span><span class="nx">maxage</span><span class="o">=</span><span class="mi">600</span>
</pre></div>
</div>
</div>
<div class="section" id="validando">
<span id="index-10"></span><h3>Validando<a class="headerlink" href="#validando" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando un recurso se tiene que actualizar tan pronto como se realiza un cambio en los datos subyacentes, el modelo de caducidad se queda corto. Con el modelo de caducidad, no se pedirá a la aplicación que devuelva la respuesta actualizada hasta que la caché finalmente se convierta en obsoleta.</p>
<p>El modelo de validación soluciona este problema. Bajo este modelo, la memoria caché sigue almacenando las respuestas. La diferencia es que, por cada petición, la caché pregunta a la aplicación cuando o no la respuesta memorizada sigue siendo válida. Si la caché todavía <em>es</em> válida, tu aplicación debe devolver un código de estado 304 y no el contenido. Esto le dice a la caché que está bien devolver la respuesta memorizada.</p>
<p>Bajo este modelo, sobre todo ahorras ancho de banda ya que la representación no se envía dos veces al mismo cliente (en su lugar se envía una respuesta 304). Pero si diseñas cuidadosamente tu aplicación, es posible que puedas obtener los datos mínimos necesarios para enviar una respuesta 304 y ahorrar <em>CPU</em> también (más abajo puedes ver una implementación de ejemplo).</p>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">El código de estado 304 significa &#8220;No Modificado&#8221;. Es importante porque este código de estado <em>no</em> tiene el contenido real solicitado.
En cambio, la respuesta simplemente es un ligero conjunto de instrucciones que indican a la caché que se debe utilizar la versión almacenada.</p>
</div>
<p>Al igual que con la caducidad, hay dos diferentes cabeceras <em>HTTP</em> que puedes utilizar para implementar el modelo de validación: <tt class="docutils literal"><span class="pre">Etag</span></tt> y <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>.</p>
</div>
<div class="section" id="validando-con-la-cabecera-etag">
<span id="index-11"></span><h3>Validando con la cabecera <tt class="docutils literal"><span class="pre">ETag</span></tt><a class="headerlink" href="#validando-con-la-cabecera-etag" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La cabecera <tt class="docutils literal"><span class="pre">ETag</span></tt> es una cabecera de cadena (llamada &#8220;entidad-etiqueta&#8221;) que identifica unívocamente una representación del recurso destino. Este es generado completamente y establecido por tu aplicación de modo que puedes decir, por ejemplo, si el recurso memorizado <tt class="docutils literal"><span class="pre">/sobre</span></tt> está al día con el que tu aplicación iba a devolver. Una <tt class="docutils literal"><span class="pre">ETag</span></tt> es como una huella digital y se utiliza para comparar rápidamente si dos versiones diferentes de un recurso son equivalentes. Como las huellas digitales, cada <tt class="docutils literal"><span class="pre">ETag</span></tt> debe ser única en todas las representaciones de un mismo recurso.</p>
<p>Vamos a caminar a través de una aplicación sencilla que genera el <tt class="docutils literal"><span class="pre">ETag</span></tt> como el <tt class="docutils literal"><span class="pre">md5</span></tt> del contenido:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">indexAction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;MyBundle:Main:index.html.twig&#39;</span><span class="p">);</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setETag</span><span class="p">(</span><span class="nb">md5</span><span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">()));</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">isNotModified</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">());</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El método <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> compara la <tt class="docutils literal"><span class="pre">ETag</span></tt> enviada en la <tt class="docutils literal"><span class="pre">Petición</span></tt> con la enviada en la <tt class="docutils literal"><span class="pre">Respuesta</span></tt>. Si ambas coinciden, el método establece automáticamente el código de estado de la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> a 304.</p>
<p>Este algoritmo es bastante simple y muy genérico, pero es necesario crear la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> completa antes de ser capaz de calcular la <tt class="docutils literal"><span class="pre">ETag</span></tt>, lo cual es subóptimo.
En otras palabras, esta ahorra ancho de banda, pero no ciclos de la <em>CPU</em>.</p>
<p>En la sección <a class="reference internal" href="#optimizing-cache-validation"><em>Optimizando tu código con validación</em></a>, vamos a mostrar cómo puedes utilizar la validación de manera más inteligente para determinar la validez de una caché sin hacer tanto trabajo.</p>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last"><em>Symfony2</em> también apoya <tt class="docutils literal"><span class="pre">ETags</span></tt> débiles pasando <tt class="docutils literal"><span class="pre">true</span></tt> como segundo argumento del método <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Response.html#setETag()" title="Symfony\Component\HttpFoundation\Response::setETag()"><span class="pre">setETag()</span></a></tt>.</p>
</div>
</div>
<div class="section" id="validando-con-la-cabecera-last-modified">
<span id="index-12"></span><h3>Validando con la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt><a class="headerlink" href="#validando-con-la-cabecera-last-modified" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> es la segunda forma de validación. De acuerdo con la especificación <em>HTTP</em>, &#8220;El campo de la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> indica la fecha y hora en que el servidor origen considera que la representación fue modificada por última vez&#8221;. En otras palabras, la aplicación decide si o no el contenido memorizado se ha actualizado en función de si es o no ha sido actualizado desde que la respuesta entró en caché.</p>
<p>Por ejemplo, puedes utilizar la última fecha de actualización de todos los objetos necesarios para calcular la representación del recurso como valor para el valor de la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showAction</span><span class="p">(</span><span class="nv">$articleSlug</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="nv">$articleDate</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\DateTime</span><span class="p">(</span><span class="nv">$article</span><span class="o">-&gt;</span><span class="na">getUpdatedAt</span><span class="p">());</span>
    <span class="nv">$authorDate</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\DateTime</span><span class="p">(</span><span class="nv">$author</span><span class="o">-&gt;</span><span class="na">getUpdatedAt</span><span class="p">());</span>

    <span class="nv">$date</span> <span class="o">=</span> <span class="nv">$authorDate</span> <span class="o">&gt;</span> <span class="nv">$articleDate</span> <span class="o">?</span> <span class="nv">$authorDate</span> <span class="o">:</span> <span class="nv">$articleDate</span><span class="p">;</span>

    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setLastModified</span><span class="p">(</span><span class="nv">$date</span><span class="p">);</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">isNotModified</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">());</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El método <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> compara la cabecera <tt class="docutils literal"><span class="pre">If-Modified-Since</span></tt> enviada por la petición con la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> situada en la respuesta. Si son equivalentes, la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> establecerá un código de estado 304.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">La cabecera <tt class="docutils literal"><span class="pre">If-Modified-Since</span></tt> de la petición es igual a la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> de la última respuesta enviada al cliente por ese recurso en particular.
Así es como se comunican el cliente y el servidor entre ellos y deciden si el recurso se ha actualizado desde que se memorizó.</p>
</div>
</div>
<div class="section" id="optimizando-tu-codigo-con-validacion">
<span id="optimizing-cache-validation"></span><span id="index-13"></span><h3>Optimizando tu código con validación<a class="headerlink" href="#optimizando-tu-codigo-con-validacion" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El objetivo principal de cualquier estrategia de memoria caché es aligerar la carga de la aplicación.
Dicho de otra manera, cuanto menos hagas en tu aplicación para devolver una respuesta 304, mejor. El método <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> hace exactamente eso al exponer un patrón simple y eficiente:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showAction</span><span class="p">(</span><span class="nv">$articleSlug</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Obtiene la mínima información para calcular la ETag</span>
    <span class="c1">// o el valor de Last-Modified (basado en la petición,</span>
    <span class="c1">// los datos se recuperan de una base de datos o un par</span>
    <span class="c1">// clave-valor guardado, por ejemplo)</span>
    <span class="nv">$article</span> <span class="o">=</span> <span class="c1">// ...</span>

    <span class="c1">// crea una respuesta con una cabecera ETag y/o Last-Modified</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setETag</span><span class="p">(</span><span class="nv">$article</span><span class="o">-&gt;</span><span class="na">computeETag</span><span class="p">());</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setLastModified</span><span class="p">(</span><span class="nv">$article</span><span class="o">-&gt;</span><span class="na">getPublishedAt</span><span class="p">());</span>

    <span class="c1">// verifica que la respuesta no se ha modificado para la petición dada</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">isNotModified</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">()))</span> <span class="p">{</span>
        <span class="c1">// devuelve la instancia de la aplicación</span>
        <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// aquí haz algo más - como recuperar más datos</span>
        <span class="nv">$comments</span> <span class="o">=</span> <span class="c1">// ...</span>

        <span class="c1">// o reproduce una plantilla con la $response que acabas de iniciar</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span>
            <span class="s1">&#39;MyBundle:MyController:article.html.twig&#39;</span><span class="p">,</span>
            <span class="k">array</span><span class="p">(</span><span class="s1">&#39;article&#39;</span> <span class="o">=&gt;</span> <span class="nv">$article</span><span class="p">,</span> <span class="s1">&#39;comments&#39;</span> <span class="o">=&gt;</span> <span class="nv">$comments</span><span class="p">),</span>
            <span class="nv">$response</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cuando la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> no es modificada, el <tt class="docutils literal"><span class="pre">isNotModified()</span></tt> automáticamente fija el código de estado de la respuesta a <tt class="docutils literal"><span class="pre">304</span></tt>, remueve el contenido, y remueve algunas cabeceras que no deben estar presentes en respuestas <tt class="docutils literal"><span class="pre">304</span></tt> (consulta
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Response.html#setNotModified()" title="Symfony\Component\HttpFoundation\Response::setNotModified()"><span class="pre">setNotModified()</span></a></tt>).</p>
</div>
<div class="section" id="variando-la-respuesta">
<span id="index-14"></span><h3>Variando la respuesta<a class="headerlink" href="#variando-la-respuesta" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Hasta ahora, hemos supuesto que cada <em>URI</em> tiene exactamente una representación del recurso destino. De forma predeterminada, la caché <em>HTTP</em> se memoriza usando la <em>URI</em> del recurso como la clave de caché. Si dos personas solicitan la misma <em>URI</em> de un recurso memorizable, la segunda persona recibirá la versión en caché.</p>
<p>A veces esto no es suficiente y diferentes versiones de la misma <em>URI</em> necesitan memorizarse en caché basándose en uno o más valores de las cabeceras de la petición. Por ejemplo, si comprimes las páginas cuando el cliente lo permite, cualquier <em>URI</em> tiene dos representaciones:
una cuando el cliente es compatible con la compresión, y otra cuando no. Esta determinación se hace por el valor de la cabecera <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> de la petición.</p>
<p>En este caso, necesitamos que la memoria almacene una versión comprimida y otra sin comprimir de la respuesta para la <em>URI</em> particular y devolverlas basándose en el valor de la cabecera <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt>. Esto se hace usando la cabecera <tt class="docutils literal"><span class="pre">Vary</span></tt> de la respuesta, la cual es una lista separada por comas de diferentes cabeceras cuyos valores lanzan una representación diferente de los recursos solicitados:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">Vary</span><span class="o">:</span> <span class="nx">Accept</span><span class="o">-</span><span class="nx">Encoding</span><span class="p">,</span> <span class="nx">User</span><span class="o">-</span><span class="nx">Agent</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">Esta cabecera <tt class="docutils literal"><span class="pre">Vary</span></tt> particular debería memorizar diferentes versiones de cada recurso en base a la <em>URI</em> y el valor de las cabeceras <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> y <tt class="docutils literal"><span class="pre">User-Agent</span></tt> de la petición.</p>
</div>
<p>El objeto <tt class="docutils literal"><span class="pre">Respuesta</span></tt> ofrece una interfaz limpia para gestionar la cabecera <tt class="docutils literal"><span class="pre">Vary</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// establece una cabecera vary</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setVary</span><span class="p">(</span><span class="s1">&#39;Accept-Encoding&#39;</span><span class="p">);</span>

<span class="c1">// establece múltiples cabeceras vary</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setVary</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;Accept-Encoding&#39;</span><span class="p">,</span> <span class="s1">&#39;User-Agent&#39;</span><span class="p">));</span>
</pre></div>
</div>
<p>El método <tt class="docutils literal"><span class="pre">setVary()</span></tt> toma un nombre de cabecera o un arreglo de nombres de cabecera de cual respuesta varía.</p>
</div>
<div class="section" id="caducidad-y-validacion">
<h3>Caducidad y validación<a class="headerlink" href="#caducidad-y-validacion" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Por supuesto, puedes utilizar tanto la caducidad como la validación de la misma <tt class="docutils literal"><span class="pre">Respuesta</span></tt>.
La caducidad gana a la validación, te puedes beneficiar de lo mejor de ambos mundos. En otras palabras, utilizando tanto la caducidad como la validación, puedes instruir a la caché para que sirva el contenido memorizado, mientras que revisas de nuevo algún intervalo (de  caducidad) para verificar que el contenido sigue siendo válido.</p>
</div>
<div class="section" id="mas-metodos-de-respuesta">
<span id="index-15"></span><h3>Más métodos de respuesta<a class="headerlink" href="#mas-metodos-de-respuesta" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La clase <tt class="docutils literal"><span class="pre">Respuesta</span></tt> proporciona muchos métodos más relacionados con la caché. Estos son los más útiles:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Marca la respuesta como obsoleta</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">expire</span><span class="p">();</span>

<span class="c1">// Fuerza a la respuesta a devolver una adecuada respuesta 304 sin contenido</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setNotModified</span><span class="p">();</span>
</pre></div>
</div>
<p>Además, puedes configurar muchas de las cabeceras <em>HTTP</em> relacionadas con la caché a través del método <tt class="docutils literal"><span class="pre">setCache()</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Establece la configuración de caché en una llamada</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setCache</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;etag&#39;</span>          <span class="o">=&gt;</span> <span class="nv">$etag</span><span class="p">,</span>
    <span class="s1">&#39;last_modified&#39;</span> <span class="o">=&gt;</span> <span class="nv">$date</span><span class="p">,</span>
    <span class="s1">&#39;max_age&#39;</span>       <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;s_maxage&#39;</span>      <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;public&#39;</span>        <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
    <span class="c1">// &#39;private&#39;    =&gt; true,</span>
<span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="usando-inclusion-del-borde-lateral">
<span id="edge-side-includes"></span><span id="index-16"></span><h2>Usando inclusión del borde lateral<a class="headerlink" href="#usando-inclusion-del-borde-lateral" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las pasarelas de caché son una excelente forma de hacer que tu sitio web tenga un mejor desempeño. Pero tienen una limitación: sólo podrán memorizar páginas enteras. Si no puedes memorizar todas las páginas o si partes de una página tienen &#8220;más&#8221; elementos dinámicos, se te acabó la suerte. Afortunadamente, <em>Symfony2</em> ofrece una solución para estos casos, basada ​​en una tecnología llamada <a class="reference external" href="http://www.w3.org/TR/esi-lang">ESI</a>, o Inclusión de bordes laterales (Edge Side Includes). Akamaï escribió esta especificación hace casi 10 años, y esta permite que partes específicas de una página tengan una estrategia de memorización diferente a la de la página principal.</p>
<p>La especificación <em>ESI</em> describe las etiquetas que puedes incrustar en tus páginas para comunicarte con la pasarela de caché. <em>Symfony2</em> sólo implementa una etiqueta, <tt class="docutils literal"><span class="pre">include</span></tt>, ya que es la única útil fuera del contexto de Akamaï:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;body&gt;</span>
    Some content

    <span class="c">&lt;!-- Aquí incluye el contenido de otra página --&gt;</span>
    <span class="nt">&lt;esi:include</span> <span class="na">src=</span><span class="s">&quot;http://...&quot;</span> <span class="nt">/&gt;</span>

    More content
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Observa que en el ejemplo cada etiqueta <em>ESI</em> tiene una <em>URL</em> completamente cualificada.
Una etiqueta <em>ESI</em> representa un fragmento de página que se puede recuperar a través de la <em>URL</em>.</p>
</div>
<p>Cuando se maneja una petición, la pasarela de caché obtiene toda la página de su caché o la pide a partir de la interfaz de administración de tu aplicación. Si la respuesta contiene una o más etiquetas <em>ESI</em>, estas se procesan de la misma manera. En otras palabras, la pasarela caché o bien, recupera el fragmento de página incluida en su caché o de nuevo pide el fragmento de página desde la interfaz de administración de tu aplicación. Cuando se han resuelto todas las etiquetas <em>ESI</em>, la pasarela caché une cada una en la página principal y envía el contenido final al cliente.</p>
<p>Todo esto sucede de forma transparente a nivel de la pasarela caché (es decir, fuera de tu aplicación). Como verás, si decides tomar ventaja de las etiquetas <em>ESI</em>, <em>Symfony2</em> hace que el proceso de incluirlas sea casi sin esfuerzo.</p>
<div class="section" id="usando-esi-en-symfony2">
<h3>Usando <em>ESI</em> en <em>Symfony2</em><a class="headerlink" href="#usando-esi-en-symfony2" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Primero, para usar <em>ESI</em>, asegúrate de activarlo en la configuración de tu aplicación:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">framework</span><span class="p-Indicator">:</span>
    <span class="c1"># ...</span>
    <span class="l-Scalar-Plain">esi</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">enabled</span><span class="p-Indicator">:</span> <span class="nv">true</span> <span class="p-Indicator">}</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><pre>&lt;!-- app/config/config.xml --&gt;
&lt;framework:config ...&gt;
    &lt;!-- ... --&gt;
    &lt;framework:esi enabled="true" /&gt;
&lt;/framework:config&gt;</pre>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/config.php</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;framework&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="c1">// ...</span>
    <span class="s1">&#39;esi&#39;</span>    <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;enabled&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">),</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Ahora, supongamos que tenemos una página que es relativamente estable, a excepción de un teletipo de noticias en la parte inferior del contenido. Con <em>ESI</em>, podemos memorizar el teletipo de noticias independiente del resto de la página.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">indexAction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;MyBundle:MyController:index.html.twig&#39;</span><span class="p">);</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En este ejemplo, hemos dado a la caché de la página completa un tiempo de vida de diez minutos.
En seguida, vamos a incluir el teletipo de noticias en la plantilla incorporando una acción.
Esto se hace a través del ayudante <tt class="docutils literal"><span class="pre">render</span></tt> (Consulta <a class="reference internal" href="templating.html#templating-embedding-controller"><em>Integrando controladores</em></a> para más detalles).</p>
<p>Como el contenido integrado viene de otra página (o controlador en este caso), <em>Symfony2</em> utiliza el ayudante <tt class="docutils literal"><span class="pre">render</span></tt> estándar para configurar las etiquetas <em>ESI</em>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">render</span> <span class="s1">&#39;...:news&#39;</span> <span class="k">with</span> <span class="o">{},</span> <span class="o">{</span><span class="s1">&#39;standalone&#39;</span><span class="o">:</span> <span class="kp">true</span><span class="o">}</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="o">&lt;?</span><span class="nx">php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;actions&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;...:noticias&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;standalone&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">))</span> <span class="cp">?&gt;</span><span class="x"></span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Al establecer <tt class="docutils literal"><span class="pre">standalone</span></tt> a <tt class="docutils literal"><span class="pre">true</span></tt>, le dices a <em>Symfony2</em> que la acción se debe reproducir como una etiqueta <em>ESI</em>. Tal vez te preguntes por qué querría usar un ayudante en vez de escribir la etiqueta <em>ESI</em> en si misma. Eso es porque usar un ayudante hace que tu aplicación trabaje, incluso si no hay pasarela caché instalada. Vamos a ver cómo funciona.</p>
<p>Cuando <tt class="docutils literal"><span class="pre">standalone</span></tt> es <tt class="docutils literal"><span class="pre">false</span></tt> (predeterminado), <em>Symfony2</em> combina el contenido de la página incluida en la principal antes de enviar la respuesta al cliente. Pero cuando <tt class="docutils literal"><span class="pre">standalone</span></tt> es <tt class="docutils literal"><span class="pre">true</span></tt>, <em>y</em> si <em>Symfony2</em> detecta que está hablando con una pasarela caché compatible con <em>ESI</em>, genera una etiqueta <tt class="docutils literal"><span class="pre">include</span></tt> <em>ESI</em>. Pero si no hay una pasarela caché o si no es compatible con <em>ESI</em>, <em>Symfony2</em> termina fusionando el contenido de las páginas incluidas en la principal como lo habría hecho si <tt class="docutils literal"><span class="pre">standalone</span></tt> se hubiera establecido en <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last"><em>Symfony2</em> detecta si una pasarela caché admite <em>ESI</em> a través de otra especificación Akamaï que fuera de la caja es compatible con el delegado inverso de <em>Symfony2</em>.</p>
</div>
<p>La acción integrada ahora puede especificar sus propias reglas de caché, totalmente independientes de la página principal.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">newsAction</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Con <em>ESI</em>, la caché de la página completa será válida durante 600 segundos, pero la caché del componente de noticias sólo dura 60 segundos.</p>
<p>Un requisito de <em>ESI</em>, sin embargo, es que la acción incrustada sea accesible a través de una <em>URL</em> para que la pasarela caché se pueda buscar independientemente del resto de la página. Por supuesto, una acción no se puede acceder a través de una <em>URL</em> a menos que haya una ruta que apunte a la misma. <em>Symfony2</em> se encarga de esto a través de una ruta genérica y un controlador. Para que la etiqueta <em>ESI</em> <tt class="docutils literal"><span class="pre">include</span></tt> funcione correctamente, debes definir la ruta <tt class="docutils literal"><span class="pre">_internal</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/routing.yml</span>
<span class="l-Scalar-Plain">_internal</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">resource</span><span class="p-Indicator">:</span> <span class="s">&quot;@FrameworkBundle/Resources/config/routing/internal.xml&quot;</span>
    <span class="l-Scalar-Plain">prefix</span><span class="p-Indicator">:</span>   <span class="l-Scalar-Plain">/_internal</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/routing.xml --&gt;</span>
<span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>

<span class="nt">&lt;routes</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/routing&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&quot;@FrameworkBundle/Resources/config/routing/internal.xml&quot;</span> <span class="na">prefix=</span><span class="s">&quot;/_internal&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/routes&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/routing.php</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Routing\RouteCollection</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Routing\Route</span><span class="p">;</span>

<span class="nv">$collection</span><span class="o">-&gt;</span><span class="na">addCollection</span><span class="p">(</span><span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">import</span><span class="p">(</span><span class="s1">&#39;@FrameworkBundle/Resources/config/routing/internal.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;/_internal&#39;</span><span class="p">));</span>

<span class="k">return</span> <span class="nv">$collection</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">Puesto que esta ruta permite que todas las acciones se accedan a través de una <em>URL</em>, posiblemente desees protegerla usando el cortafuegos de <em>Symfony2</em> (permitiendo acceder al rango <em>IP</em> del delegado inverso). Consulta la sección <a class="reference internal" href="security.html#book-security-securing-ip"><em>Protegiendo por IP</em></a> del <a class="reference internal" href="security.html"><em>Capítulo de seguridad</em></a> para más información de cómo hacer esto.</p>
</div>
<p>Una gran ventaja de esta estrategia de memoria caché es que puedes hacer tu aplicación tan dinámica como sea necesario y al mismo tiempo, tocar la aplicación lo menos posible.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Una vez que comiences a usar <em>ESI</em>, recuerda usar siempre la directiva <tt class="docutils literal"><span class="pre">s-maxage</span></tt> en lugar de <tt class="docutils literal"><span class="pre">max-age</span></tt>. Como el navegador nunca recibe recursos agregados, no es consciente del subcomponente, y por lo tanto obedecerá la directiva <tt class="docutils literal"><span class="pre">max-age</span></tt> y memorizará la página completa. Y no quieres eso.</p>
</div>
<p>El ayudante <tt class="docutils literal"><span class="pre">render</span></tt> es compatible con otras dos útiles opciones:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">alt</span></tt>: utilizada como el atributo <tt class="docutils literal"><span class="pre">alt</span></tt> en la etiqueta <em>ESI</em>, el cual te permite especificar una <em>URL</em> alternativa para utilizarla si no se puede encontrar <tt class="docutils literal"><span class="pre">src</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">ignore_errors</span></tt>: si la fijas a <tt class="docutils literal"><span class="pre">true</span></tt>, se agrega un atributo <tt class="docutils literal"><span class="pre">onerror</span></tt> a la <em>ESI</em> con un valor de <tt class="docutils literal"><span class="pre">continue</span></tt> indicando que, en caso de una falla, la pasarela caché simplemente debe eliminar la etiqueta <em>ESI</em> silenciosamente.</li>
</ul>
</div>
</div>
<div class="section" id="invalidando-la-cache">
<span id="http-cache-invalidation"></span><span id="index-17"></span><h2>Invalidando la caché<a class="headerlink" href="#invalidando-la-cache" title="Enlazar permanentemente con este título">¶</a></h2>
<blockquote>
<div>&#8220;Sólo hay dos cosas difíciles en Ciencias de la Computación: Invalidación de caché y nombrar cosas&#8221; &#8211;Phil Karlton</div></blockquote>
<p>Nunca debería ser necesario invalidar los datos memorizados en caché porque la invalidación ya se tiene en cuenta de forma nativa en los modelos de caché <em>HTTP</em>. Si utilizas la validación, por definición, no será necesario invalidar ninguna cosa; y si utilizas la caducidad y necesitas invalidar un recurso, significa que estableciste la fecha de caducidad muy adelante en el futuro.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Debido a que la invalidación es un tema específico de cada tipo de delegado inverso, si no te preocupa la invalidación, puedes cambiar entre los delegados inversos sin cambiar nada en el código de tu aplicación.</p>
</div>
<p>En realidad, todos los delegados inversas proporcionan una manera de purgar datos almacenados en caché, pero lo debes evitar tanto como sea posible. La forma más habitual es purgar la caché de una <em>URL</em> dada solicitándola con el método especial <tt class="docutils literal"><span class="pre">PURGE</span></tt> de <em>HTTP</em>.</p>
<p>Aquí está cómo puedes configurar la caché del delegado inverso de <em>Symfony2</em> para apoyar al método <tt class="docutils literal"><span class="pre">PURGE</span></tt> de <em>HTTP</em>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/AppCache.php</span>

<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AppCache</span> <span class="k">extends</span> <span class="nx">HttpCache</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">invalidate</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;PURGE&#39;</span> <span class="o">!==</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getMethod</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">parent</span><span class="o">::</span><span class="na">invalidate</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getStore</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">purge</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getUri</span><span class="p">()))</span> <span class="p">{</span>
            <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="s1">&#39;Not purged&#39;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s1">&#39;Purged&#39;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="first admonition-title">Prudencia</p>
<p class="last">De alguna manera, debes proteger el método <tt class="docutils literal"><span class="pre">PURGE</span></tt> de  <em>HTTP</em> para evitar que alguien aleatoriamente purgue los datos memorizados.</p>
</div>
</div>
<div class="section" id="resumen">
<h2>Resumen<a class="headerlink" href="#resumen" title="Enlazar permanentemente con este título">¶</a></h2>
<p><em>Symfony2</em> fue diseñado para seguir las reglas probadas de la carretera: <em>HTTP</em>. El almacenamiento en caché no es una excepción. Dominar el sistema caché de <em>Symfony2</em> significa familiarizarse con los modelos de caché <em>HTTP</em> y usarlos eficientemente. Esto significa que, en lugar de confiar sólo en la documentación de <em>Symfony2</em> y ejemplos de código, tienes acceso a un mundo de conocimientos relacionados con la memorización en caché <em>HTTP</em> y la pasarela caché, tal como <em>Varnish</em>.</p>
</div>
<div class="section" id="aprende-mas-en-el-recetario">
<h2>Aprende más en el recetario<a class="headerlink" href="#aprende-mas-en-el-recetario" title="Enlazar permanentemente con este título">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="../cookbook/cache/varnish.html"><em>Cómo utilizar Varnish para acelerar mi sitio web</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <a href="https://github.com/symfony/symfony-standard"><img style="position: fixed; top: 0; right: 0; border: 0;" src="http://gitnacho.github.com/tnp/img/comun/bifurcame.png" alt="Bifúrcame en GitHub" /></a>
  
  <div style="width:740px;margin:10px auto;">
    
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="translation.html" title="Traduciendo"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="security.html" title="Seguridad"
             >anterior</a> |</li>
        <li><a href="../index.html">en Español</a> &raquo;</li>
          <li><a href="index.html" >Libro</a> &raquo;</li> 
      </ul>
    </div>
  </div>


   <div style="width: 740px; margin: 0 auto;">
     <div id="disqus_thread"></div>
     
    <div class="footer">
        &copy; Copyright 2011-2012, Traducido por Nacho Pacheco.
      Actualizado por última vez en May 21, 2012.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
   </div>
   <script type="text/javascript">
    var disqus_shortname = 'documentos-mx';
    var disqus_developer = 1;
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
   </script>
   <noscript>
     Por favor activa JavaScript para ver los <a href="http://disqus.com/?ref_noscript">comentarios accionados por Disqus.</a>
   </noscript>

  </body>
</html>