
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Bases de datos y Doctrine (“El modelo”) &mdash; Manual de Symfony2 en Español</title>
    
    <link rel="stylesheet" href="../_static/tnp.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.12',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/icotnp.ico"/>
    <link rel="top" title="Manual de Symfony2 en Español" href="../index.html" />
    <link rel="up" title="Libro" href="index.html" />
    <link rel="next" title="Probando" href="testing.html" />
    <link rel="prev" title="Creando y usando plantillas" href="templating.html" /> 
  </head>
  <body>
  <div class="imalogo">
    
  <a href="../index.html"><img src="http://gitnacho.github.com/tnp/img/sf/logo-big.gif" alt="Edición estándar de Symfony2" />
  
    <a href="http://gitnacho.github.com/tnp/"><img src="http://gitnacho.github.com/tnp/_static/normaltnp.png" alt="Traducciones de Nacho Pacheco" /></a>
    <div class="social">
      <a href="https://twitter.com/share" class="twitter-share-button" data-via="esymfony" data-lang="es">Tweet</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    </div>
    <div id="searchbox">
      <form class="searc " action="../search.html" method="get">
      <input type="search" name="q" placeholder="Término a buscar" />
      <input type="submit" value="Ir" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
    

    
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="testing.html" title="Probando"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="templating.html" title="Creando y usando plantillas"
             accesskey="P">anterior</a> |</li>
        <li><a href="../index.html">en Español</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Libro</a> &raquo;</li> 
      </ul>
    </div>
  </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="bases-de-datos-y-doctrine-el-modelo">
<span id="index-0"></span><h1>Bases de datos y <em>Doctrine</em> (&#8220;El modelo&#8221;)<a class="headerlink" href="#bases-de-datos-y-doctrine-el-modelo" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Seamos realistas, una de las tareas más comunes y desafiantes para cualquier aplicación consiste en la persistencia y lectura de información hacia y desde una base de datos. Afortunadamente, <em>Symfony</em> viene integrado con <a class="reference external" href="http://www.doctrine-project.org/">Doctrine</a>, una biblioteca, cuyo único objetivo es dotarte de poderosas herramientas para facilitarte eso. En este capítulo, aprenderás la filosofía básica detrás de <em>Doctrine</em> y verás lo fácil que puede ser trabajar con una base de datos.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p><em>Doctrine</em> está totalmente desconectado de <em>Symfony</em> y utilizarlo es opcional.
Este capítulo trata acerca del <em>ORM</em> de <em>Doctrine</em>, el cual te permite asignar objetos a una base de datos relacional (tal como <em>MySQL</em>, <em>PostgreSQL</em> o <em>Microsoft SQL</em>).
Si prefieres utilizar las consultas de base de datos en bruto, es fácil, y se explica en el artículo &#8220;<a class="reference internal" href="../cookbook/doctrine/dbal.html"><em>Cómo utiliza Doctrine la capa DBAL</em></a>&#8221; del recetario.</p>
<p class="last">También puedes persistir tus datos en <a class="reference external" href="http://www.mongodb.org/">MongoDB</a> utilizando la biblioteca <em>ODM</em> de <em>Doctrine</em>. Para más información, lee la documentación en &#8220;<a class="reference internal" href="../bundles/DoctrineMongoDBBundle/index.html"><em>DoctrineMongoDBBundle</em></a>&#8221;.</p>
</div>
<div class="section" id="un-sencillo-ejemplo-un-producto">
<h2>Un sencillo ejemplo: Un producto<a class="headerlink" href="#un-sencillo-ejemplo-un-producto" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La forma más fácil de entender cómo funciona <em>Doctrine</em> es verlo en acción.
En esta sección, configuraremos tu base de datos, crearemos un objeto <tt class="docutils literal"><span class="pre">Producto</span></tt>, lo persistiremos en la base de datos y lo recuperaremos de nuevo.</p>
<div class="sidebar">
<p class="first sidebar-title">El código del ejemplo</p>
<p>Si quieres seguir el ejemplo de este capítulo, crea el paquete <tt class="docutils literal"><span class="pre">AcmeStoreBundle</span></tt> ejecutando la orden:</p>
<div class="last highlight-bash"><div class="highlight"><pre>php app/console generate:bundle --namespace<span class="o">=</span>Acme/StoreBundle
</pre></div>
</div>
</div>
<div class="section" id="configurando-la-base-de-datos">
<h3>Configurando la base de datos<a class="headerlink" href="#configurando-la-base-de-datos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Antes de comenzar realmente, tendrás que configurar tu información de conexión a la base de datos. Por convención, esta información se suele configurar en el archivo
<tt class="file docutils literal"><span class="pre">app/config/parameters.yml</span></tt>:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/parameters.yml</span>
<span class="l-Scalar-Plain">parameters</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">database_driver</span><span class="p-Indicator">:</span>   <span class="l-Scalar-Plain">pdo_mysql</span>
    <span class="l-Scalar-Plain">database_host</span><span class="p-Indicator">:</span>     <span class="l-Scalar-Plain">localhost</span>
    <span class="l-Scalar-Plain">database_name</span><span class="p-Indicator">:</span>     <span class="l-Scalar-Plain">proyecto_de_prueba</span>
    <span class="l-Scalar-Plain">database_user</span><span class="p-Indicator">:</span>     <span class="l-Scalar-Plain">nombre_de_usuario</span>
    <span class="l-Scalar-Plain">database_password</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">contraseña</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Definir la configuración a través de <tt class="file docutils literal"><span class="pre">parameters.yml</span></tt> sólo es una convención.
Los parámetros definidos en este archivo son referidos en el archivo de configuración principal al configurar <em>Doctrine</em>:</p>
<div class="highlight-yaml"><pre>doctrine:
    dbal:
        driver:   %database_driver%
        host:     %database_host%
        dbname:   %database_name%
        user:     %database_user%
        password: %database_password%</pre>
</div>
<p class="last">Al separar la información de la base de datos en un archivo independiente, puedes mantener fácilmente diferentes versiones del archivo en cada servidor. Además, puedes almacenar fácilmente la configuración de la base de datos (o cualquier otra información sensible) fuera de tu proyecto, posiblemente dentro de tu configuración de <em>Apache</em>, por ejemplo. Para más información, consulta <a class="reference internal" href="../cookbook/configuration/external_parameters.html"><em>Cómo configurar parámetros externos en el contenedor de servicios</em></a>.</p>
</div>
<p>Ahora que <em>Doctrine</em> conoce tu base de datos, posiblemente tenga que crear la base de datos para ti:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:database:create
</pre></div>
</div>
</div>
<div class="section" id="creando-una-clase-entidad">
<h3>Creando una clase Entidad<a class="headerlink" href="#creando-una-clase-entidad" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Supongamos que estás construyendo una aplicación donde necesitas mostrar tus productos.
Sin siquiera pensar en <em>Doctrine</em> o en una base de datos, ya sabes que necesitas un objeto <tt class="docutils literal"><span class="pre">Producto</span></tt> para representar los productos. Crea esta clase en el directorio <tt class="docutils literal"><span class="pre">Entity</span></tt> de tu paquete <tt class="docutils literal"><span class="pre">AcmeStoreBundle</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Entity/Product.php</span>
<span class="k">namespace</span> <span class="nx">Acme\StoreBundle\Entity</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="nv">$name</span><span class="p">;</span>

    <span class="k">protected</span> <span class="nv">$price</span><span class="p">;</span>

    <span class="k">protected</span> <span class="nv">$description</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La clase &#8212;a menudo llamada &#8220;entidad&#8221;, es decir, <em>una clase básica que contiene datos</em>&#8212; es simple y ayuda a cumplir con el requisito del negocio de productos que necesita tu aplicación. Sin embargo, esta clase no se puede guardar en una base de datos &#8212;es sólo una clase <em>PHP</em> simple.</p>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p>Una vez que aprendas los conceptos de <em>Doctrine</em>, puedes dejar que <em>Doctrine</em> cree por ti la entidad para esta clase:</p>
<div class="last highlight-bash"><div class="highlight"><pre>php app/console doctrine:generate:entity --entity<span class="o">=</span><span class="s2">&quot;AcmeStoreBundle:Product&quot;</span> --fields<span class="o">=</span><span class="s2">&quot;name:string(255) price:float description:text&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="agregando-informacion-de-asignacion">
<span id="book-doctrine-adding-mapping"></span><span id="index-1"></span><h3>Agregando información de asignación<a class="headerlink" href="#agregando-informacion-de-asignacion" title="Enlazar permanentemente con este título">¶</a></h3>
<p><em>Doctrine</em> te permite trabajar con bases de datos de una manera mucho más interesante que solo recuperar filas de una tabla basada en columnas de una matriz. En cambio, <em>Doctrine</em> te permite persistir <em>objetos</em> completos a la base de datos y recuperar objetos completos desde la base de datos. Esto funciona asignando una clase <em>PHP</em> a una tabla de la base de datos, y las propiedades de esa clase <em>PHP</em> a las columnas de la tabla:</p>
<img alt="../_images/doctrine_image_1_es.png" class="align-center" src="../_images/doctrine_image_1_es.png" />
<p>Para que <em>Doctrine</em> sea capaz de hacer esto, sólo hay que crear &#8220;metadatos&#8221;, o la configuración que le dice a <em>Doctrine</em> exactamente cómo debe <em>asignar</em> la clase <tt class="docutils literal"><span class="pre">Producto</span></tt> y sus propiedades a la base de datos. Estos metadatos se pueden especificar en una variedad de formatos diferentes, incluyendo <em>YAML</em>, <em>XML</em> o directamente dentro de la clase <tt class="docutils literal"><span class="pre">Producto</span></tt> a través de anotaciones:</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Un paquete sólo puede aceptar un formato para definir metadatos. Por ejemplo, no es posible mezclar metadatos para la clase Entidad definidos en <em>YAML</em> con definidos en anotaciones <em>PHP</em>.</p>
</div>
<div class="configuration-block">
<ul class="simple">
<li><em>Annotations</em><div class="highlight-php-annotations"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Entity/Product.php</span>
<span class="k">namespace</span> <span class="nx">Acme\StoreBundle\Entity</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Doctrine\ORM\Mapping</span> <span class="k">as</span> <span class="nx">ORM</span><span class="p">;</span>

<span class="sd">/**</span>
<span class="sd"> * @ORM\Entity</span>
<span class="sd"> * @ORM\Table(name=&quot;product&quot;)</span>
<span class="sd"> */</span>
<span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * @ORM\Id</span>
<span class="sd">     * @ORM\Column(type=&quot;integer&quot;)</span>
<span class="sd">     * @ORM\GeneratedValue(strategy=&quot;AUTO&quot;)</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="nv">$id</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * @ORM\Column(type=&quot;string&quot;, length=100)</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="nv">$name</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * @ORM\Column(type=&quot;decimal&quot;, scale=2)</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="nv">$price</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * @ORM\Column(type=&quot;text&quot;)</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="nv">$description</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># src/Acme/StoreBundle/Resources/config/doctrine/Product.orm.yml</span>
<span class="l-Scalar-Plain">Acme\StoreBundle\Entity\Product</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">entity</span>
    <span class="l-Scalar-Plain">table</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">product</span>
    <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">integer</span>
            <span class="l-Scalar-Plain">generator</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">strategy</span><span class="p-Indicator">:</span> <span class="nv">AUTO</span> <span class="p-Indicator">}</span>
    <span class="l-Scalar-Plain">fields</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">string</span>
            <span class="l-Scalar-Plain">length</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">100</span>
        <span class="l-Scalar-Plain">price</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">decimal</span>
            <span class="l-Scalar-Plain">scale</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">2</span>
        <span class="l-Scalar-Plain">description</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">text</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- src/Acme/StoreBundle/Resources/config/doctrine/Product.orm.xml --&gt;</span>
<span class="nt">&lt;doctrine-mapping</span> <span class="na">xmlns=</span><span class="s">&quot;http://doctrine-project.org/schemas/orm/doctrine-mapping&quot;</span>
      <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
      <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://doctrine-project.org/schemas/orm/doctrine-mapping</span>
<span class="s">                    http://doctrine-project.org/schemas/orm/doctrine-mapping.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;entity</span> <span class="na">name=</span><span class="s">&quot;Acme\StoreBundle\Entity\Product&quot;</span> <span class="na">table=</span><span class="s">&quot;product&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;id</span> <span class="na">name=</span><span class="s">&quot;id&quot;</span> <span class="na">type=</span><span class="s">&quot;integer&quot;</span> <span class="na">column=</span><span class="s">&quot;id&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;generator</span> <span class="na">strategy=</span><span class="s">&quot;AUTO&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/id&gt;</span>
        <span class="nt">&lt;field</span> <span class="na">name=</span><span class="s">&quot;name&quot;</span> <span class="na">column=</span><span class="s">&quot;name&quot;</span> <span class="na">type=</span><span class="s">&quot;string&quot;</span> <span class="na">length=</span><span class="s">&quot;100&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;field</span> <span class="na">name=</span><span class="s">&quot;price&quot;</span> <span class="na">column=</span><span class="s">&quot;price&quot;</span> <span class="na">type=</span><span class="s">&quot;decimal&quot;</span> <span class="na">scale=</span><span class="s">&quot;2&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;field</span> <span class="na">name=</span><span class="s">&quot;description&quot;</span> <span class="na">column=</span><span class="s">&quot;description&quot;</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/entity&gt;</span>
<span class="nt">&lt;/doctrine-mapping&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">El nombre de la tabla es opcional y si la omites, será determinada automáticamente basándose en el nombre de la clase entidad.</p>
</div>
<p><em>Doctrine</em> te permite elegir entre una amplia variedad de diferentes tipos de campo, cada uno con sus propias opciones. Para obtener información sobre los tipos de campo disponibles, consulta la sección <a class="reference internal" href="#book-doctrine-field-types"><em>Referencia de tipos de campo Doctrine</em></a>.</p>
<div class="admonition-ver-tambien admonition seealso">
<p class="first admonition-title">Ver también</p>
<p class="last">También puedes consultar la <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html">Documentación de asignación básica</a> de <em>Doctrine</em> para todos los detalles sobre la información de asignación. Si utilizas anotaciones, tendrás que prefijar todas las anotaciones con <tt class="docutils literal"><span class="pre">ORM\</span></tt> (por ejemplo, <tt class="docutils literal"><span class="pre">ORM\Column(..)</span></tt>), lo cual no se muestra en la documentación de <em>Doctrine</em>. También tendrás que incluir la declaración <tt class="docutils literal"><span class="pre">use</span> <span class="pre">Doctrine\ORM\Mapping</span> <span class="pre">as</span> <span class="pre">ORM;</span></tt> la cual <em>importa</em> el prefijo <tt class="docutils literal"><span class="pre">ORM</span></tt> de las anotaciones.</p>
</div>
<div class="admonition caution">
<p class="first admonition-title">Prudencia</p>
<p class="last">Ten cuidado de que tu nombre de clase y propiedades no estén asignados a un área protegida por palabras clave de <tt class="docutils literal"><span class="pre">SQL</span></tt> (tal como <tt class="docutils literal"><span class="pre">group</span></tt> o <tt class="docutils literal"><span class="pre">user</span></tt>). Por ejemplo, si el nombre de clase de tu entidad es <tt class="docutils literal"><span class="pre">group</span></tt>, entonces, de manera predeterminada, el nombre de la tabla será <tt class="docutils literal"><span class="pre">group</span></tt>, lo cual provocará un error en algunos motores <tt class="docutils literal"><span class="pre">SQL</span></tt>. Consulta la <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html#quoting-reserved-words">Documentación de palabras clave reservadas por SQL</a> para que sepas cómo escapar correctamente estos nombres.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Cuando utilizas otra biblioteca o programa (es decir, <em>Doxygen</em>) que utiliza anotaciones, debes colocar la anotación <tt class="docutils literal"><span class="pre">&#64;IgnoreAnnotation</span></tt> en la clase para indicar que se deben ignorar las anotaciones <em>Symfony</em>.</p>
<p>Por ejemplo, para evitar que la anotación <tt class="docutils literal"><span class="pre">&#64;fn</span></tt> lance una excepción, añade lo siguiente:</p>
<div class="last highlight-php"><div class="highlight"><pre><span class="sd">/**</span>
<span class="sd"> * @IgnoreAnnotation(&quot;fn&quot;)</span>
<span class="sd"> */</span>
<span class="k">class</span> <span class="nc">Product</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="generando-captadores-y-definidores">
<h3>Generando captadores y definidores<a class="headerlink" href="#generando-captadores-y-definidores" title="Enlazar permanentemente con este título">¶</a></h3>
<p>A pesar de que <em>Doctrine</em> ahora sabe cómo persistir en la base de datos un objeto <tt class="docutils literal"><span class="pre">Producto</span></tt>, la clase en sí realmente no es útil todavía. Puesto que <tt class="docutils literal"><span class="pre">Producto</span></tt> es sólo una clase <em>PHP</em> regular, es necesario crear métodos captadores y definidores (por ejemplo, <tt class="docutils literal"><span class="pre">getName()</span></tt>, <tt class="docutils literal"><span class="pre">setName()</span></tt>) para poder acceder a sus propiedades (ya que las propiedades son <tt class="docutils literal"><span class="pre">protegidas</span></tt>). Afortunadamente, <em>Doctrine</em> puede hacer esto por ti con la siguiente orden:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:generate:entities Acme/StoreBundle/Entity/Product
</pre></div>
</div>
<p>Esta orden se asegura de que se generen todos los captadores y definidores para la clase <tt class="docutils literal"><span class="pre">Producto</span></tt>. Esta es una orden segura &#8212; la puedes ejecutar una y otra vez: sólo genera captadores y definidores que no existen (es decir, no sustituye métodos existentes).</p>
<div class="sidebar">
<p class="first sidebar-title">Más sobre <tt class="docutils literal"><span class="pre">doctrine:generate:entities</span></tt></p>
<p>con la orden <tt class="docutils literal"><span class="pre">doctrine:generate:entities</span></tt> puedes:</p>
<blockquote>
<div><ul class="simple">
<li>generar captadores y definidores,</li>
<li>generar clases repositorio configuradas con la anotación <tt class="docutils literal"><span class="pre">&#64;ORM\Entity(repositoryClass=&quot;...&quot;)</span></tt>,</li>
<li>generar el constructor adecuado para relaciones <tt class="docutils literal"><span class="pre">1:n</span></tt> y <tt class="docutils literal"><span class="pre">n:m</span></tt>.</li>
</ul>
</div></blockquote>
<p>La orden <tt class="docutils literal"><span class="pre">doctrine:generate:entities</span></tt> guarda una copia de seguridad del <tt class="file docutils literal"><span class="pre">Producto.php</span></tt> original llamada <tt class="file docutils literal"><span class="pre">Producto.php~</span></tt>. En algunos casos, la presencia de este archivo puede provocar un error &#8220;No se puede redeclarar la clase&#8221;. Lo puedes quitar sin problemas.</p>
<p class="last">Ten en cuenta que no <em>necesitas</em> usar esta orden. <em>Doctrine</em> no se basa en la generación de código. Al igual que con las clases de <em>PHP</em> normales, sólo tienes que asegurarte de que sus propiedades protegidas/privadas tienen métodos captadores y definidores.
Puesto que cuando utilizas <em>Doctrine</em> es algo que tienes que hacer comúnmente, se creó esta orden.</p>
</div>
<p>También puedes generar todas las entidades conocidas (es decir, cualquier clase <em>PHP</em> con información de asignación <em>Doctrine</em>) de un paquete o un espacio de nombres completo:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:generate:entities AcmeStoreBundle
php app/console doctrine:generate:entities Acme
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">A <em>Doctrine</em> no le importa si tus propiedades son <tt class="docutils literal"><span class="pre">protegidas</span></tt> o <tt class="docutils literal"><span class="pre">privadas</span></tt>, o si una propiedad tiene o no una función captadora o definidora.
Aquí, los captadores y definidores se generan sólo porque los necesitarás para interactuar con tu objeto <em>PHP</em>.</p>
</div>
</div>
<div class="section" id="creando-tablas-esquema-de-la-base-de-datos">
<h3>Creando tablas/esquema de la base de datos<a class="headerlink" href="#creando-tablas-esquema-de-la-base-de-datos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora tienes una clase <tt class="docutils literal"><span class="pre">Producto</span></tt> utilizable con información de asignación de modo que <em>Doctrine</em> sabe exactamente cómo persistirla. Por supuesto, en tu base de datos aún no tienes la tabla <tt class="docutils literal"><span class="pre">producto</span></tt> correspondiente. Afortunadamente, <em>Doctrine</em> puede crear automáticamente todas las tablas de la base de datos necesarias para cada entidad conocida en tu aplicación. Para ello, ejecuta:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:schema:update --force
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p>En realidad, esta orden es increíblemente poderosa. Esta compara cómo se <em>debe</em> ver tu base de datos (en base a la información de asignación de tus entidades) con la forma en que <em>realmente</em> se ve, y genera las declaraciones <tt class="docutils literal"><span class="pre">SQL</span></tt> necesarias para <em>actualizar</em> la base de datos a su verdadera forma. En otras palabras, si agregas una nueva propiedad asignando metadatos a <tt class="docutils literal"><span class="pre">Producto</span></tt> y ejecutas esta tarea de nuevo, vas a generar la declaración <tt class="docutils literal"><span class="pre">alter</span> <span class="pre">table</span></tt> necesaria para añadir la nueva columna a la tabla <tt class="docutils literal"><span class="pre">Producto</span></tt> existente.</p>
<p class="last">Una forma aún mejor para tomar ventaja de esta funcionalidad es a través de las <a class="reference internal" href="../bundles/DoctrineMigrationsBundle/index.html"><em>migraciones</em></a>, las cuales te permiten generar estas instrucciones <tt class="docutils literal"><span class="pre">SQL</span></tt> y almacenarlas en las clases de la migración, mismas que puedes ejecutar sistemáticamente en tu servidor en producción con el fin de seguir la pista y migrar el esquema de la base de datos segura y fiablemente.</p>
</div>
<p>Tu base de datos ahora cuenta con una tabla <tt class="docutils literal"><span class="pre">producto</span></tt> completamente funcional, con columnas que coinciden con los metadatos que has especificado.</p>
</div>
<div class="section" id="persistiendo-objetos-a-la-base-de-datos">
<h3>Persistiendo objetos a la base de datos<a class="headerlink" href="#persistiendo-objetos-a-la-base-de-datos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora que tienes asignada una entidad <tt class="docutils literal"><span class="pre">Producto</span></tt> y la tabla <tt class="docutils literal"><span class="pre">Producto</span></tt> correspondiente, estás listo para persistir los datos a la base de datos. Desde el interior de un controlador, esto es bastante fácil. Agrega el siguiente método al <tt class="docutils literal"><span class="pre">DefaultController</span></tt> del paquete:</p>
<div class="highlight-php"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Controller/DefaultController.php</span>
<span class="k">use</span> <span class="nx">Acme\StoreBundle\Entity\Product</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Response</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">createAction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$product</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Product</span><span class="p">();</span>
    <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">setName</span><span class="p">(</span><span class="s1">&#39;A Foo Bar&#39;</span><span class="p">);</span>
    <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">setPrice</span><span class="p">(</span><span class="s1">&#39;19.99&#39;</span><span class="p">);</span>
    <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">setDescription</span><span class="p">(</span><span class="s1">&#39;Lorem ipsum dolor&#39;</span><span class="p">);</span>

    <span class="nv">$em</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getManager</span><span class="p">();</span>
    <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">persist</span><span class="p">(</span><span class="nv">$product</span><span class="p">);</span>
    <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">flush</span><span class="p">();</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;Created product id &#39;</span><span class="o">.</span><span class="nv">$product</span><span class="o">-&gt;</span><span class="na">getId</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si estás siguiendo este ejemplo, tendrás que crear una ruta que apunte a esta acción para verla trabajar.</p>
</div>
<p>Vamos a recorrer este ejemplo:</p>
<ul class="simple">
<li><strong>líneas 8-11</strong> En esta sección, creas una instancia y trabajas con el objeto <tt class="docutils literal"><span class="pre">$product</span></tt> como con cualquier otro objeto <em>PHP</em> normal;</li>
<li><strong>línea 13</strong> Esta línea consigue un objeto <em>gestor de entidades</em> de <em>Doctrine</em>, el cual es responsable de manejar el proceso de persistir y recuperar objetos hacia y desde la base de datos;</li>
<li><strong>línea 14</strong> El método <tt class="docutils literal"><span class="pre">persist()</span></tt> dice a <em>Doctrine</em> que &#8220;maneje&#8221; el objeto <tt class="docutils literal"><span class="pre">$product</span></tt>. Esto en realidad no provoca una consulta que se deba introducir en la base de datos (todavía).</li>
<li><strong>línea 15</strong> Cuando se llama al método <tt class="docutils literal"><span class="pre">flush()</span></tt>, <em>Doctrine</em> examina todos los objetos que está gestionando para ver si es necesario persistirlos en la base de datos. En este ejemplo, el objeto <tt class="docutils literal"><span class="pre">$product</span></tt> aún no se ha persistido, por lo tanto el gestor de la entidad ejecuta una consulta <tt class="docutils literal"><span class="pre">INSERT</span></tt> y crea una fila en la tabla <tt class="docutils literal"><span class="pre">producto</span></tt>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">De hecho, ya que <em>Doctrine</em> es consciente de todas tus entidades gestionadas, cuando se llama al método <tt class="docutils literal"><span class="pre">flush()</span></tt>, calcula el conjunto de cambios y ejecuta la(s) consulta(s) más eficiente(s) posible(s). Por ejemplo, si persistes un total de 100 objetos <tt class="docutils literal"><span class="pre">Producto</span></tt> y, posteriormente llamas a <tt class="docutils literal"><span class="pre">flush()</span></tt>, <em>Doctrine</em> creará una <em>sola</em> declaración preparada y la volverá a utilizar para cada inserción. Este patrón se conoce como <em>Unidad de trabajo</em>, y se usa porque es rápido y eficiente.</p>
</div>
<p>Al crear o actualizar objetos, el flujo de trabajo siempre es el mismo. En la siguiente sección, verás cómo <em>Doctrine</em> es lo suficientemente inteligente como para emitir automáticamente una consulta <em>UPDATE</em> si ya existe el registro en la base de datos.</p>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last"><em>Doctrine</em> proporciona una biblioteca que te permite cargar en tu proyecto mediante programación los datos de prueba (es decir, &#8220;datos accesorios&#8221;). Para más información, consulta <a class="reference internal" href="../bundles/DoctrineFixturesBundle/index.html"><em>DoctrineFixturesBundle</em></a>.</p>
</div>
</div>
<div class="section" id="recuperando-objetos-desde-la-base-de-datos">
<h3>Recuperando objetos desde la base de datos<a class="headerlink" href="#recuperando-objetos-desde-la-base-de-datos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Recuperar un objeto desde la base de datos es aún más fácil. Por ejemplo, supongamos que has configurado una ruta para mostrar un <tt class="docutils literal"><span class="pre">Producto</span></tt> específico en función del valor de su <tt class="docutils literal"><span class="pre">id</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showAction</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$product</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">)</span>
        <span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$product</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">createNotFoundException</span><span class="p">(</span><span class="s1">&#39;No product found for id &#39;</span><span class="o">.</span><span class="nv">$id</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// haz algo, como pasar el objeto $product a una plantilla</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Al consultar por un determinado tipo de objeto, siempre utilizas lo que se conoce como &#8220;repositorio&#8221;. Puedes pensar en un repositorio como una clase <em>PHP</em>, cuyo único trabajo consiste en ayudarte a buscar las entidades de una determinada clase. Puedes acceder al objeto <tt class="docutils literal"><span class="pre">repositorio</span></tt> de una clase <tt class="docutils literal"><span class="pre">entidad</span></tt> a través de:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$repository</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">La cadena <tt class="docutils literal"><span class="pre">AcmeStoreBundle:Product</span></tt> es un método abreviado que puedes utilizar en cualquier lugar de <em>Doctrine</em> en lugar del nombre de clase completo de la entidad (es decir, <tt class="docutils literal"><span class="pre">Acme\StoreBundle\Entity\Product</span></tt>).
Mientras que tu entidad viva bajo el espacio de nombres <tt class="docutils literal"><span class="pre">Entity</span></tt> de tu paquete, esto debe funcionar.</p>
</div>
<p>Una vez que tengas tu repositorio, tienes acceso a todo tipo de útiles métodos:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// consulta por la clave principal (generalmente &quot;id&quot;)</span>
<span class="nv">$product</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

<span class="c1">// nombres dinámicos de métodos para buscar un valor basad en columna</span>
<span class="nv">$product</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">findOneById</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
<span class="nv">$product</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">findOneByName</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>

<span class="c1">// recupera TODOS los productos</span>
<span class="nv">$products</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">findAll</span><span class="p">();</span>

<span class="c1">// busca un grupo de productos basándose en el valor de una columna arbitraria</span>
<span class="nv">$products</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">findByPrice</span><span class="p">(</span><span class="mf">19.99</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Por supuesto, también puedes realizar consultas complejas, acerca de las cuales aprenderás más en la sección <a class="reference internal" href="#book-doctrine-queries"><em>Consultando por objetos</em></a>.</p>
</div>
<p>También puedes tomar ventaja de los útiles métodos <tt class="docutils literal"><span class="pre">findBy</span></tt> y <tt class="docutils literal"><span class="pre">findOneBy</span></tt> para recuperar objetos fácilmente basándote en varias condiciones:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// consulta por un producto que coincide en nombre y precio</span>
<span class="nv">$product</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">findOneBy</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;name&#39;</span>  <span class="o">=&gt;</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;price&#39;</span> <span class="o">=&gt;</span> <span class="mf">19.99</span><span class="p">));</span>

<span class="c1">// pregunta por todos los productos en que coincide el nombre, ordenados por precio</span>
<span class="nv">$product</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">findBy</span><span class="p">(</span>
    <span class="k">array</span><span class="p">(</span><span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span>
    <span class="k">array</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;ASC&#39;</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p>Cuando reproduces una página, puedes ver, en la esquina inferior derecha de la barra de herramientas de depuración web, cuántas consultas se realizaron.</p>
<a class="reference internal image-reference" href="../_images/doctrine_web_debug_toolbar_es.png"><img alt="../_images/doctrine_web_debug_toolbar_es.png" class="align-center" src="../_images/doctrine_web_debug_toolbar_es.png" style="width: 262.5px;" /></a>
<p class="last">Si haces clic en el icono, se abrirá el generador de perfiles, mostrando las consultas exactas que se hicieron.</p>
</div>
</div>
<div class="section" id="actualizando-un-objeto">
<h3>Actualizando un objeto<a class="headerlink" href="#actualizando-un-objeto" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Una vez que hayas extraído un objeto de <em>Doctrine</em>, actualizarlo es relativamente fácil. Supongamos que tienes una ruta que asigna un identificador de producto a una acción de actualización de un controlador:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">updateAction</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$em</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getManager</span><span class="p">();</span>
    <span class="nv">$product</span> <span class="o">=</span> <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$product</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">createNotFoundException</span><span class="p">(</span><span class="s1">&#39;No product found for id &#39;</span><span class="o">.</span><span class="nv">$id</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">setName</span><span class="p">(</span><span class="s1">&#39;New product name!&#39;</span><span class="p">);</span>
    <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">flush</span><span class="p">();</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">redirect</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">generateUrl</span><span class="p">(</span><span class="s1">&#39;homepage&#39;</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La actualización de un objeto únicamente consta de tres pasos:</p>
<ol class="arabic simple">
<li>Recuperar el objeto desde <em>Doctrine</em>;</li>
<li>Modificar el objeto;</li>
<li>Invocar a <tt class="docutils literal"><span class="pre">flush()</span></tt> en el gestor de la entidad</li>
</ol>
<p>Ten en cuenta que no es necesario llamar a <tt class="docutils literal"><span class="pre">$em-&gt;persist($product)</span></tt>. Recuerda que este método simplemente dice a <em>Doctrine</em> que procese o &#8220;vea&#8221; el objeto <tt class="docutils literal"><span class="pre">$product</span></tt>.
En este caso, ya que recuperaste el objeto <tt class="docutils literal"><span class="pre">$product</span></tt> desde <em>Doctrine</em>, este ya está gestionado.</p>
</div>
<div class="section" id="eliminando-un-objeto">
<h3>Eliminando un objeto<a class="headerlink" href="#eliminando-un-objeto" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Eliminar un objeto es muy similar, pero requiere una llamada al método <tt class="docutils literal"><span class="pre">remove()</span></tt> del gestor de la entidad:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$em</span><span class="o">-&gt;</span><span class="na">remove</span><span class="p">(</span><span class="nv">$product</span><span class="p">);</span>
<span class="nv">$em</span><span class="o">-&gt;</span><span class="na">flush</span><span class="p">();</span>
</pre></div>
</div>
<p>Como es de esperar, el método <tt class="docutils literal"><span class="pre">remove()</span></tt> notifica a <em>Doctrine</em> que deseas eliminar la entidad de la base de datos. La consulta <em>DELETE</em> real, sin embargo, no se ejecuta efectivamente hasta que se invoca al método <tt class="docutils literal"><span class="pre">flush()</span></tt>.</p>
</div>
</div>
<div class="section" id="consultando-por-objetos">
<span id="book-doctrine-queries"></span><h2>Consultando por objetos<a class="headerlink" href="#consultando-por-objetos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Ya has visto cómo el objeto <tt class="docutils literal"><span class="pre">repositorio</span></tt> te permite ejecutar consultas básicas sin ningún trabajo:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

<span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">findOneByName</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Por supuesto, <em>Doctrine</em> también te permite escribir consultas más complejas utilizando el lenguaje de consulta <em>Doctrine</em> (<em>DQL</em> por <em>Doctrine Query Language</em>). <em>DQL</em> es similar a <em>SQL</em>, excepto que debes imaginar que estás consultando por uno o más objetos de una clase entidad (por ejemplo, <tt class="docutils literal"><span class="pre">Producto</span></tt>) en lugar de consultar por filas de una tabla (por ejemplo, <tt class="docutils literal"><span class="pre">producto</span></tt>).</p>
<p>Al consultar en <em>Doctrine</em>, tienes dos opciones: escribir consultas <em>Doctrine</em> puras o utilizar el generador de consultas de <em>Doctrine</em>.</p>
<div class="section" id="consultando-objetos-con-dql">
<h3>Consultando objetos con <em>DQL</em><a class="headerlink" href="#consultando-objetos-con-dql" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Imagina que deseas consultar los productos, pero sólo quieres devolver aquellos que cuestan más de <tt class="docutils literal"><span class="pre">19.99</span></tt>, ordenados del más barato al más caro. Desde el interior de un controlador, haz lo siguiente:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$em</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getManager</span><span class="p">();</span>
<span class="nv">$query</span> <span class="o">=</span> <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">createQuery</span><span class="p">(</span>
    <span class="s1">&#39;SELECT p FROM AcmeStoreBundle:Product p WHERE p.price &gt; :price ORDER BY p.price ASC&#39;</span>
<span class="p">)</span><span class="o">-&gt;</span><span class="na">setParameter</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;19.99&#39;</span><span class="p">);</span>

<span class="nv">$products</span> <span class="o">=</span> <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">getResult</span><span class="p">();</span>
</pre></div>
</div>
<p>Si te sientes cómodo con <em>SQL</em>, entonces debes sentir a <em>DQL</em> muy natural. La mayor diferencia es que necesitas pensar en términos de &#8220;objetos&#8221; en lugar de filas de una base de datos. Por esta razón, seleccionas <em>from</em> <tt class="docutils literal"><span class="pre">AcmeStoreBundle:Product</span></tt> y luego lo apodas <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
<p>El método <tt class="docutils literal"><span class="pre">getResult()</span></tt> devuelve una matriz de resultados. Si estás preguntando por un solo objeto, en su lugar puedes utilizar el método <tt class="docutils literal"><span class="pre">getSingleResult()</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$product</span> <span class="o">=</span> <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">getSingleResult</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="first admonition-title">Prudencia</p>
<p>El método <tt class="docutils literal"><span class="pre">getSingleResult()</span></tt> lanza una excepción <tt class="docutils literal"><span class="pre">Doctrine\ORM\NoResultException</span></tt> si no se devuelven resultados y una <tt class="docutils literal"><span class="pre">Doctrine\ORM\NonUniqueResultException</span></tt> si se devuelve <em>más</em> de un resultado. Si utilizas este método, posiblemente tengas que envolverlo en un bloque <tt class="docutils literal"><span class="pre">try-catch</span></tt> y asegurarte de que sólo devuelve un resultado (si estás consultando sobre algo que sea viable podrías regresar más de un resultado):</p>
<div class="last highlight-php"><div class="highlight"><pre><span class="nv">$query</span> <span class="o">=</span> <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">createQuery</span><span class="p">(</span><span class="s1">&#39;SELECT ....&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">setMaxResults</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="k">try</span> <span class="p">{</span>
    <span class="nv">$product</span> <span class="o">=</span> <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">getSingleResult</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">\Doctrine\Orm\NoResultException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$product</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</div>
<p>La sintaxis <em>DQL</em> es increíblemente poderosa, permitiéndote unir entidades fácilmente (el tema de las <a class="reference internal" href="#book-doctrine-relations"><em>relaciones</em></a> se describe más adelante), agrupación, etc. Para más información, consulta la documentación oficial de <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html">Doctrine Query Language</a>.</p>
<div class="sidebar">
<p class="first sidebar-title">Configurando parámetros</p>
<p>Toma nota del método <tt class="docutils literal"><span class="pre">setParameter()</span></tt>. Cuando trabajes con <em>Doctrine</em>, siempre es buena idea establecer cualquier valor externo como &#8220;marcador de posición&#8221;, tal cómo lo hicimos en la consulta anterior:</p>
<div class="highlight-text"><div class="highlight"><pre>... WHERE p.price &gt; :price ...
</pre></div>
</div>
<p>Entonces, puedes establecer el valor del marcador de posición <tt class="docutils literal"><span class="pre">price</span></tt> llamando al método <tt class="docutils literal"><span class="pre">setParameter()</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="o">-&gt;</span><span class="na">setParameter</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;19.99&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Utilizar parámetros en lugar de colocar los valores directamente en la cadena de consulta, se hace para prevenir ataques de inyección <tt class="docutils literal"><span class="pre">SQL</span></tt> y <em>siempre</em> se debe hacer.
Si estás utilizando varios parámetros, puedes establecer simultáneamente sus valores usando el método <tt class="docutils literal"><span class="pre">setParameters()</span></tt>:</p>
<div class="last highlight-php"><div class="highlight"><pre><span class="o">-&gt;</span><span class="na">setParameters</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;price&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;19.99&#39;</span><span class="p">,</span>
    <span class="s1">&#39;name&#39;</span>  <span class="o">=&gt;</span> <span class="s1">&#39;Foo&#39;</span><span class="p">,</span>
<span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="usando-el-generador-de-consultas-de-doctrine">
<h3>Usando el generador de consultas de <em>Doctrine</em><a class="headerlink" href="#usando-el-generador-de-consultas-de-doctrine" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En lugar de escribir las consultas directamente, también puedes usar el <tt class="docutils literal"><span class="pre">QueryBuilder</span></tt> de <em>Doctrine</em> para hacer el mismo trabajo con una agradable interfaz orientada a objetos.
Si usas un <em>IDE</em>, también puedes tomar ventaja del autocompletado a medida que escribes los nombres de método. Desde el interior de un controlador:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$repository</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">);</span>

<span class="nv">$query</span> <span class="o">=</span> <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">createQueryBuilder</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">where</span><span class="p">(</span><span class="s1">&#39;p.price &gt; :price&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">setParameter</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;19.99&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">orderBy</span><span class="p">(</span><span class="s1">&#39;p.price&#39;</span><span class="p">,</span> <span class="s1">&#39;ASC&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">getQuery</span><span class="p">();</span>

<span class="nv">$products</span> <span class="o">=</span> <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">getResult</span><span class="p">();</span>
</pre></div>
</div>
<p>El objeto <tt class="docutils literal"><span class="pre">QueryBuilder</span></tt> contiene todos los métodos necesarios para construir tu consulta. Al invocar al método <tt class="docutils literal"><span class="pre">getQuery()</span></tt>, el generador de consultas devuelve un objeto <tt class="docutils literal"><span class="pre">Query</span></tt> normal, el cual es el mismo objeto que construiste directamente en la sección anterior.</p>
<p>Para más información sobre el generador de consultas de <em>Doctrine</em>, consulta la documentación del <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html">Generador de consultas</a> de <em>Doctrine</em>.</p>
</div>
<div class="section" id="repositorio-de-clases-personalizado">
<h3>Repositorio de clases personalizado<a class="headerlink" href="#repositorio-de-clases-personalizado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En las secciones anteriores, comenzamos a construir y utilizar consultas más complejas desde el interior de un controlador. Con el fin de aislar, probar y volver a usar estas consultas, es buena idea crear una clase <tt class="docutils literal"><span class="pre">repositorio</span></tt> personalizada para tu <tt class="docutils literal"><span class="pre">entidad</span></tt> y agregar métodos con tu lógica de consulta allí.</p>
<p>Para ello, agrega el nombre de la clase del repositorio a la definición de asignación.</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Annotations</em><div class="highlight-php-annotations"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Entity/Product.php</span>
<span class="k">namespace</span> <span class="nx">Acme\StoreBundle\Entity</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Doctrine\ORM\Mapping</span> <span class="k">as</span> <span class="nx">ORM</span><span class="p">;</span>

<span class="sd">/**</span>
<span class="sd"> * @ORM\Entity(repositoryClass=&quot;Acme\StoreBundle\Repository\ProductRepository&quot;)</span>
<span class="sd"> */</span>
<span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># src/Acme/StoreBundle/Resources/config/doctrine/Product.orm.yml</span>
<span class="l-Scalar-Plain">Acme\StoreBundle\Entity\Product</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">entity</span>
    <span class="l-Scalar-Plain">repositoryClass</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Acme\StoreBundle\Repository\ProductRepository</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- src/Acme/StoreBundle/Resources/config/doctrine/Product.orm.xml --&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;doctrine-mapping&gt;</span>

    <span class="nt">&lt;entity</span> <span class="na">name=</span><span class="s">&quot;Acme\StoreBundle\Entity\Product&quot;</span>
            <span class="na">repository-class=</span><span class="s">&quot;Acme\StoreBundle\Repository\ProductRepository&quot;</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- ... --&gt;</span>
    <span class="nt">&lt;/entity&gt;</span>
<span class="nt">&lt;/doctrine-mapping&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p><em>Doctrine</em> puede generar la clase <tt class="docutils literal"><span class="pre">repositorio</span></tt> por ti ejecutando la misma orden usada anteriormente para generar los métodos captadores y definidores omitidos:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:generate:entities Acme
</pre></div>
</div>
<p>A continuación, agrega un nuevo método &#8212; <tt class="docutils literal"><span class="pre">findAllOrderedByName()</span></tt> &#8212; a la clase repositorio recién generada. Este método debe consultar todas las entidades <tt class="docutils literal"><span class="pre">Producto</span></tt>, ordenadas alfabéticamente.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Repository/ProductRepository.php</span>
<span class="k">namespace</span> <span class="nx">Acme\StoreBundle\Repository</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Doctrine\ORM\EntityRepository</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ProductRepository</span> <span class="k">extends</span> <span class="nx">EntityRepository</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">findAllOrderedByName</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getManager</span><span class="p">()</span>
            <span class="o">-&gt;</span><span class="na">createQuery</span><span class="p">(</span><span class="s1">&#39;SELECT p FROM AcmeStoreBundle:Product p ORDER BY p.name ASC&#39;</span><span class="p">)</span>
            <span class="o">-&gt;</span><span class="na">getResult</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">Puedes acceder al gestor de la entidad a través de <tt class="docutils literal"><span class="pre">$this-&gt;getManager()</span></tt> desde el repositorio.</p>
</div>
<p>Puedes utilizar este nuevo método al igual que los métodos de búsqueda predefinidos del repositorio:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$em</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getManager</span><span class="p">();</span>
<span class="nv">$products</span> <span class="o">=</span> <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">)</span>
               <span class="o">-&gt;</span><span class="na">findAllOrderedByName</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Al utilizar una clase repositorio personalizada, todavía tienes acceso a los métodos de búsqueda predeterminados como <tt class="docutils literal"><span class="pre">find()</span></tt> y <tt class="docutils literal"><span class="pre">findAll()</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="entidad-relaciones-asociaciones">
<span id="book-doctrine-relations"></span><h2>Entidad relaciones/asociaciones<a class="headerlink" href="#entidad-relaciones-asociaciones" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Supongamos que los productos en tu aplicación pertenecen exactamente a una <tt class="docutils literal"><span class="pre">&quot;category&quot;</span></tt>.
En este caso, necesitarás un objeto <tt class="docutils literal"><span class="pre">Category</span></tt> y una manera de relacionar un objeto <tt class="docutils literal"><span class="pre">Producto</span></tt> a un objeto <tt class="docutils literal"><span class="pre">Category</span></tt>. Empieza por crear la entidad <tt class="docutils literal"><span class="pre">Category</span></tt>.
Ya sabemos que tarde o temprano tendrás que persistir la clase a través de <em>Doctrine</em>, puedes dejar que <em>Doctrine</em> cree la clase para ti.</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:generate:entity --entity<span class="o">=</span><span class="s2">&quot;AcmeStoreBundle:Category&quot;</span> --fields<span class="o">=</span><span class="s2">&quot;name:string(255)&quot;</span>
</pre></div>
</div>
<p>Esta tarea genera la entidad <tt class="docutils literal"><span class="pre">Category</span></tt> para ti, con un campo <tt class="docutils literal"><span class="pre">id</span></tt>, un campo <tt class="docutils literal"><span class="pre">name</span></tt> y las funciones captadoras y definidoras asociadas.</p>
<div class="section" id="relacion-con-la-asignacion-de-metadatos">
<h3>Relación con la asignación de metadatos<a class="headerlink" href="#relacion-con-la-asignacion-de-metadatos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para relacionar las entidades <tt class="docutils literal"><span class="pre">Category</span></tt> y <tt class="docutils literal"><span class="pre">Producto</span></tt>, empieza por crear una propiedad <tt class="docutils literal"><span class="pre">products</span></tt> en la clase <tt class="docutils literal"><span class="pre">Category</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Annotations</em><div class="highlight-php-annotations"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Entity/Category.php</span>
<span class="c1">// ...</span>
<span class="k">use</span> <span class="nx">Doctrine\Common\Collections\ArrayCollection</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Category</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="sd">/**</span>
<span class="sd">     * @ORM\OneToMany(targetEntity=&quot;Product&quot;, mappedBy=&quot;category&quot;)</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="nv">$products</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">products</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayCollection</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># src/Acme/StoreBundle/Resources/config/doctrine/Category.orm.yml</span>
<span class="l-Scalar-Plain">Acme\StoreBundle\Entity\Category</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">entity</span>
    <span class="c1"># ...</span>
    <span class="l-Scalar-Plain">oneToMany</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">products</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">targetEntity</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Product</span>
            <span class="l-Scalar-Plain">mappedBy</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">category</span>
    <span class="c1"># no olvides iniciar la colección en el método __construct() de la entidad</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>En primer lugar, ya que un objeto <tt class="docutils literal"><span class="pre">Category</span></tt> debe relacionar muchos objetos <tt class="docutils literal"><span class="pre">Producto</span></tt>, agregamos una propiedad <tt class="docutils literal"><span class="pre">Productos</span></tt> para contener esos objetos <tt class="docutils literal"><span class="pre">Producto</span></tt>.
Una vez más, esto no se hace porque lo necesite <em>Doctrine</em>, sino porque tiene sentido en la aplicación para que cada <tt class="docutils literal"><span class="pre">Category</span></tt> mantenga una gran variedad de objetos <tt class="docutils literal"><span class="pre">Producto</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">El código de el método <tt class="docutils literal"><span class="pre">__construct()</span></tt> es importante porque <em>Doctrine</em> requiere que la propiedad <tt class="docutils literal"><span class="pre">$products</span></tt> sea un objeto <tt class="docutils literal"><span class="pre">ArrayCollection</span></tt>.
Este objeto se ve y actúa casi <em>exactamente</em> como una matriz, pero tiene cierta flexibilidad. Si esto te hace sentir incómodo, no te preocupes. Sólo imagina que es una <tt class="docutils literal"><span class="pre">matriz</span></tt> y estarás bien.</p>
</div>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">El valor de <tt class="docutils literal"><span class="pre">targetEntity</span></tt> en el decorador utilizado anteriormente puede hacer referencia a cualquier entidad con un espacio de nombres válido, no sólo a las entidades definidas en la misma clase. Para relacionarlo con una entidad definida en una clase o paquete diferente, escribe un espacio de nombres completo como <tt class="docutils literal"><span class="pre">targetEntity</span></tt>.</p>
</div>
<p>A continuación, ya que cada clase <tt class="docutils literal"><span class="pre">Producto</span></tt> se puede relacionar exactamente a un objeto <tt class="docutils literal"><span class="pre">Category</span></tt>, podrías desear agregar una propiedad <tt class="docutils literal"><span class="pre">$category</span></tt> a la clase <tt class="docutils literal"><span class="pre">Producto</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Annotations</em><div class="highlight-php-annotations"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Entity/Product.php</span>
<span class="c1">// ...</span>

<span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="sd">/**</span>
<span class="sd">     * @ORM\ManyToOne(targetEntity=&quot;Category&quot;, inversedBy=&quot;products&quot;)</span>
<span class="sd">     * @ORM\JoinColumn(name=&quot;category_id&quot;, referencedColumnName=&quot;id&quot;)</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="nv">$category</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># src/Acme/StoreBundle/Resources/config/doctrine/Product.orm.yml</span>
<span class="l-Scalar-Plain">Acme\StoreBundle\Entity\Product</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">entity</span>
    <span class="c1"># ...</span>
    <span class="l-Scalar-Plain">manyToOne</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">category</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">targetEntity</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Category</span>
            <span class="l-Scalar-Plain">inversedBy</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">products</span>
            <span class="l-Scalar-Plain">joinColumn</span><span class="p-Indicator">:</span>
                <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">category_id</span>
                <span class="l-Scalar-Plain">referencedColumnName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">id</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Por último, ahora que hemos agregado una nueva propiedad a ambas clases <tt class="docutils literal"><span class="pre">Category</span></tt> y <tt class="docutils literal"><span class="pre">Producto</span></tt>, le informamos a <em>Doctrine</em> que genere por ti los métodos captadores y definidores omitidos:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:generate:entities Acme
</pre></div>
</div>
<p>No hagas caso de los metadatos de <em>Doctrine</em> por un momento. Ahora tienes dos clases &#8212;<tt class="docutils literal"><span class="pre">Categoría</span></tt> y <tt class="docutils literal"><span class="pre">Producto</span></tt>&#8212; con una relación natural de uno a muchos. La clase <tt class="docutils literal"><span class="pre">Category</span></tt> tiene una matriz de objetos <tt class="docutils literal"><span class="pre">Producto</span></tt> y el objeto <tt class="docutils literal"><span class="pre">producto</span></tt> puede contener un objeto <tt class="docutils literal"><span class="pre">Category</span></tt>. En otras palabras &#8212;hemos construido tus clases de una manera que tiene sentido para tus necesidades. El hecho de que los datos se tienen que persistir en una base de datos, siempre es secundario.</p>
<p>Ahora, veamos los metadatos sobre la propiedad <tt class="docutils literal"><span class="pre">$category</span></tt> en la clase <tt class="docutils literal"><span class="pre">Producto</span></tt>. Esta información le dice a <em>Doctrine</em> que la clase está relacionada con <tt class="docutils literal"><span class="pre">Category</span></tt> y que debe guardar el <tt class="docutils literal"><span class="pre">id</span></tt> del registro de la categoría en un campo <tt class="docutils literal"><span class="pre">category_id</span></tt> que vive en la tabla <tt class="docutils literal"><span class="pre">producto</span></tt>. En otras palabras, el objeto <tt class="docutils literal"><span class="pre">Category</span></tt> relacionado se almacenará en la propiedad <tt class="docutils literal"><span class="pre">$category</span></tt>, pero tras bambalinas, <em>Doctrine</em> deberá persistir esta relación almacenando el valor del <tt class="docutils literal"><span class="pre">id</span></tt> de la categoría en una columna  <tt class="docutils literal"><span class="pre">category_id</span></tt> de la tabla <tt class="docutils literal"><span class="pre">producto</span></tt>.</p>
<img alt="../_images/doctrine_image_2_es.png" class="align-center" src="../_images/doctrine_image_2_es.png" />
<p>Los metadatos sobre la propiedad <tt class="docutils literal"><span class="pre">$products</span></tt> del objeto <tt class="docutils literal"><span class="pre">Category</span></tt> son menos importantes, y simplemente dicen a <em>Doctrine</em> que vea la propiedad <tt class="docutils literal"><span class="pre">Product.category</span></tt> para averiguar cómo se asigna la relación.</p>
<p>Antes de continuar, asegúrate de decirle a <em>Doctrine</em> que agregue la nueva tabla <tt class="docutils literal"><span class="pre">Category</span></tt>, la columna <tt class="docutils literal"><span class="pre">product.category_id</span></tt> y la nueva clave externa:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:schema:update --force
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Esta tarea sólo la deberías utilizar durante el desarrollo. Para un más robusto método de actualización sistemática de tu base de datos en producción, lee sobre las <a class="reference internal" href="../bundles/DoctrineMigrationsBundle/index.html"><em>Migraciones de Doctrine</em></a>.</p>
</div>
</div>
<div class="section" id="guardando-entidades-relacionadas">
<h3>Guardando entidades relacionadas<a class="headerlink" href="#guardando-entidades-relacionadas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora, vamos a ver el código en acción. Imagina que estás dentro de un controlador:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// ...</span>
<span class="k">use</span> <span class="nx">Acme\StoreBundle\Entity\Category</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Acme\StoreBundle\Entity\Product</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Response</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">class</span> <span class="nc">DefaultController</span> <span class="k">extends</span> <span class="nx">Controller</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">createProductAction</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$category</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Category</span><span class="p">();</span>
        <span class="nv">$category</span><span class="o">-&gt;</span><span class="na">setName</span><span class="p">(</span><span class="s1">&#39;Main Products&#39;</span><span class="p">);</span>

        <span class="nv">$product</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Product</span><span class="p">();</span>
        <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">setName</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="p">);</span>
        <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">setPrice</span><span class="p">(</span><span class="mf">19.99</span><span class="p">);</span>
        <span class="c1">// relaciona este producto a la categoría</span>
        <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">setCategory</span><span class="p">(</span><span class="nv">$category</span><span class="p">);</span>

        <span class="nv">$em</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getManager</span><span class="p">();</span>
        <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">persist</span><span class="p">(</span><span class="nv">$category</span><span class="p">);</span>
        <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">persist</span><span class="p">(</span><span class="nv">$product</span><span class="p">);</span>
        <span class="nv">$em</span><span class="o">-&gt;</span><span class="na">flush</span><span class="p">();</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span>
            <span class="s1">&#39;Created product id: &#39;</span><span class="o">.</span><span class="nv">$product</span><span class="o">-&gt;</span><span class="na">getId</span><span class="p">()</span><span class="o">.</span><span class="s1">&#39; and category id: &#39;</span><span class="o">.</span><span class="nv">$category</span><span class="o">-&gt;</span><span class="na">getId</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora, se agrega una sola fila a las tablas <tt class="docutils literal"><span class="pre">category</span></tt> y <tt class="docutils literal"><span class="pre">producto</span></tt>.
La columna <tt class="docutils literal"><span class="pre">product.category_id</span></tt> para el nuevo producto se ajusta a algún <tt class="docutils literal"><span class="pre">id</span></tt> de la nueva categoría. <em>Doctrine</em> gestiona la persistencia de esta relación para ti.</p>
</div>
<div class="section" id="recuperando-objetos-relacionados">
<h3>Recuperando objetos relacionados<a class="headerlink" href="#recuperando-objetos-relacionados" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando necesites recuperar objetos asociados, tu flujo de trabajo se ve justo como lo hacías antes. En primer lugar, buscas un objeto <tt class="docutils literal"><span class="pre">$product</span></tt> y luego accedes a su <tt class="docutils literal"><span class="pre">Category</span></tt> asociada:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showAction</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$product</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">)</span>
        <span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

    <span class="nv">$categoryName</span> <span class="o">=</span> <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">getCategory</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getName</span><span class="p">();</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En este ejemplo, primero consultas por un objeto <tt class="docutils literal"><span class="pre">Producto</span></tt> basándote en el <tt class="docutils literal"><span class="pre">id</span></tt> del producto. Este emite una consulta <em>solo</em> para los datos del producto e hidrata al objeto <tt class="docutils literal"><span class="pre">$product</span></tt> con esos datos. Más tarde, cuando llames a <tt class="docutils literal"><span class="pre">$product-&gt;getCategory()-&gt;getName()</span></tt>, <em>Doctrine</em> silenciosamente hace una segunda consulta para encontrar la <tt class="docutils literal"><span class="pre">Category</span></tt> que está relacionada con este <tt class="docutils literal"><span class="pre">Producto</span></tt>. Entonces, prepara el objeto <tt class="docutils literal"><span class="pre">$category</span></tt> y te lo devuelve.</p>
<img alt="../_images/doctrine_image_3_es.png" class="align-center" src="../_images/doctrine_image_3_es.png" />
<p>Lo importante es el hecho de que tienes fácil acceso a la categoría relacionada con el producto, pero, los datos de la categoría realmente no se recuperan hasta que pides la categoría (es decir, trata de &#8220;cargarlos de manera diferida&#8221;).</p>
<p>También puedes consultar en la dirección contraria:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showProductAction</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$category</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Category&#39;</span><span class="p">)</span>
        <span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

    <span class="nv">$products</span> <span class="o">=</span> <span class="nv">$category</span><span class="o">-&gt;</span><span class="na">getProducts</span><span class="p">();</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En este caso, ocurre lo mismo: primero consultas por un único objeto <tt class="docutils literal"><span class="pre">Category</span></tt>, y luego <em>Doctrine</em> hace una segunda consulta para recuperar los objetos <tt class="docutils literal"><span class="pre">Producto</span></tt> relacionados, pero sólo una vez/si le preguntas por ellos (es decir, cuando invoques a <tt class="docutils literal"><span class="pre">-&gt;getProducts()</span></tt>).
La variable <tt class="docutils literal"><span class="pre">$products</span></tt> es una matriz de todos los objetos <tt class="docutils literal"><span class="pre">Producto</span></tt> relacionados con el objeto <tt class="docutils literal"><span class="pre">Category</span></tt> propuesto a través de sus valores <tt class="docutils literal"><span class="pre">category_id</span></tt>.</p>
<div class="sidebar">
<p class="first sidebar-title">Relaciones y clases delegadas</p>
<p>Esta &#8220;carga diferida&#8221; es posible porque, cuando sea necesario, <em>Doctrine</em> devuelve un objeto &#8220;delegado&#8221; en lugar del verdadero objeto. Veamos de nuevo el ejemplo anterior:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$product</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

<span class="nv">$category</span> <span class="o">=</span> <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">getCategory</span><span class="p">();</span>

<span class="c1">// imprime &quot;Proxies\AcmeStoreBundleEntityCategoryProxy&quot;</span>
<span class="k">echo</span> <span class="nb">get_class</span><span class="p">(</span><span class="nv">$category</span><span class="p">);</span>
</pre></div>
</div>
<p>Este objeto delegado extiende al verdadero objeto <tt class="docutils literal"><span class="pre">Category</span></tt>, y se ve y actúa exactamente igual que él. La diferencia es que, al usar un objeto delegado, <em>Doctrine</em> puede retrasar la consulta de los datos reales de <tt class="docutils literal"><span class="pre">Category</span></tt> hasta que efectivamente se necesiten esos datos (por ejemplo, hasta que invoques a <tt class="docutils literal"><span class="pre">$category-&gt;getName()</span></tt>).</p>
<p>Las clases delegadas las genera <em>Doctrine</em> y se almacenan en el directorio cache.
Y aunque probablemente nunca te des cuenta de que tu objeto <tt class="docutils literal"><span class="pre">$category</span></tt> en realidad es un objeto delegado, es importante tenerlo en cuenta.</p>
<p class="last">En la siguiente sección, al recuperar simultáneamente los datos del producto y la categoría (a través de una <em>unión</em>), <em>Doctrine</em> devolverá el <em>verdadero</em> objeto <tt class="docutils literal"><span class="pre">Category</span></tt>, puesto que nada se tiene que cargar de forma diferida.</p>
</div>
</div>
<div class="section" id="uniendo-registros-relacionados">
<h3>Uniendo registros relacionados<a class="headerlink" href="#uniendo-registros-relacionados" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En los ejemplos anteriores, se realizaron dos consultas &#8212;una para el objeto original (por ejemplo, una <tt class="docutils literal"><span class="pre">Categoría</span></tt>)&#8212; y otra para el/los objetos relacionados (por ejemplo, los objetos <tt class="docutils literal"><span class="pre">Producto</span></tt>).</p>
<div class="admonition tip">
<p class="first admonition-title">Truco</p>
<p class="last">Recuerda que puedes ver todas las consultas realizadas durante una petición a través de la barra de herramientas de depuración web.</p>
</div>
<p>Por supuesto, si sabes por adelantado que necesitas tener acceso a los objetos, puedes evitar la segunda consulta emitiendo una unión en la consulta original. Agrega el siguiente método a la clase <tt class="docutils literal"><span class="pre">ProductRepository</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// src/Acme/StoreBundle/Repository/ProductRepository.php</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">findOneByIdJoinedToCategory</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$query</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getManager</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="na">createQuery</span><span class="p">(</span><span class="s1">&#39;</span>
<span class="s1">            SELECT p, c FROM AcmeStoreBundle:Product p</span>
<span class="s1">            JOIN p.category c</span>
<span class="s1">            WHERE p.id = :id&#39;</span>
        <span class="p">)</span><span class="o">-&gt;</span><span class="na">setParameter</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nv">$id</span><span class="p">);</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">getSingleResult</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">\Doctrine\ORM\NoResultException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora, puedes utilizar este método en el controlador para consultar un objeto <tt class="docutils literal"><span class="pre">Producto</span></tt> y su correspondiente <tt class="docutils literal"><span class="pre">Category</span></tt> con una sola consulta:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showAction</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$product</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getDoctrine</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="na">getRepository</span><span class="p">(</span><span class="s1">&#39;AcmeStoreBundle:Product&#39;</span><span class="p">)</span>
        <span class="o">-&gt;</span><span class="na">findOneByIdJoinedToCategory</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

    <span class="nv">$category</span> <span class="o">=</span> <span class="nv">$product</span><span class="o">-&gt;</span><span class="na">getCategory</span><span class="p">();</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mas-informacion-sobre-asociaciones">
<h3>Más información sobre asociaciones<a class="headerlink" href="#mas-informacion-sobre-asociaciones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Esta sección ha sido una introducción a un tipo común de relación entre entidades, la relación uno a muchos. Para obtener detalles más avanzados y ejemplos de cómo utilizar otros tipos de relaciones (por ejemplo, <tt class="docutils literal"><span class="pre">uno</span> <span class="pre">a</span> <span class="pre">uno</span></tt>, <tt class="docutils literal"><span class="pre">muchos</span> <span class="pre">a</span> <span class="pre">muchos</span></tt>), consulta la sección <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html">Asignando asociaciones</a> en la documentación de <em>Doctrine</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si estás utilizando anotaciones, tendrás que prefijar todas las anotaciones con <tt class="docutils literal"><span class="pre">ORM\</span></tt> (por ejemplo, <tt class="docutils literal"><span class="pre">ORM\OneToMany</span></tt>), lo cual no se refleja en la documentación de <em>Doctrine</em>. También tendrás que incluir la declaración <tt class="docutils literal"><span class="pre">use</span> <span class="pre">Doctrine\ORM\Mapping</span> <span class="pre">as</span> <span class="pre">ORM;</span></tt> la cual <em>importa</em> el prefijo <tt class="docutils literal"><span class="pre">ORM</span></tt> de las anotaciones.</p>
</div>
</div>
</div>
<div class="section" id="configurando">
<h2>Configurando<a class="headerlink" href="#configurando" title="Enlazar permanentemente con este título">¶</a></h2>
<p><em>Doctrine</em> es altamente configurable, aunque probablemente nunca tendrás que preocuparte de la mayor parte de sus opciones. Para más información sobre la configuración de <em>Doctrine</em>, consulta la sección <em>Doctrine</em> del <a class="reference internal" href="../reference/configuration/doctrine.html"><em>Manual de referencia</em></a>.</p>
</div>
<div class="section" id="ciclo-de-vida-de-las-retrollamadas">
<h2>Ciclo de vida de las retrollamadas<a class="headerlink" href="#ciclo-de-vida-de-las-retrollamadas" title="Enlazar permanentemente con este título">¶</a></h2>
<p>A veces, es necesario realizar una acción justo antes o después de insertar, actualizar o eliminar una entidad. Este tipo de acciones se conoce como &#8220;ciclo de vida&#8221; de las retrollamadas, ya que son métodos retrollamados que necesitas ejecutar durante las diferentes etapas del ciclo de vida de una entidad (por ejemplo, cuando la entidad es insertada, actualizada, eliminada, etc.)</p>
<p>Si estás utilizando anotaciones para los metadatos, empieza por permitir el ciclo de vida de las retrollamadas. Esto no es necesario si estás usando <em>YAML</em> o <em>XML</em> para tu asignación:</p>
<div class="highlight-php-annotations"><div class="highlight"><pre><span class="sd">/**</span>
<span class="sd"> * @ORM\Entity()</span>
<span class="sd"> * @ORM\HasLifecycleCallbacks()</span>
<span class="sd"> */</span>
<span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora, puedes decir a <em>Doctrine</em> que ejecute un método en cualquiera de los eventos del ciclo de vida disponibles. Por ejemplo, supongamos que deseas establecer una columna de fecha <tt class="docutils literal"><span class="pre">created</span></tt> a la fecha actual, sólo cuando se persiste por primera vez la entidad (es decir, se inserta):</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Annotations</em><div class="highlight-php-annotations"><div class="highlight"><pre><span class="sd">/**</span>
<span class="sd"> * @ORM\PrePersist</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">setCreatedValue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">created</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\DateTime</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># src/Acme/StoreBundle/Resources/config/doctrine/Product.orm.yml</span>
<span class="l-Scalar-Plain">Acme\StoreBundle\Entity\Product</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">entity</span>
    <span class="c1"># ...</span>
    <span class="l-Scalar-Plain">lifecycleCallbacks</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">prePersist</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span> <span class="nv">setCreatedValue</span> <span class="p-Indicator">]</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- src/Acme/StoreBundle/Resources/config/doctrine/Product.orm.xml --&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;doctrine-mapping&gt;</span>

    <span class="nt">&lt;entity</span> <span class="na">name=</span><span class="s">&quot;Acme\StoreBundle\Entity\Product&quot;</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- ... --&gt;</span>
            <span class="nt">&lt;lifecycle-callbacks&gt;</span>
                <span class="nt">&lt;lifecycle-callback</span> <span class="na">type=</span><span class="s">&quot;prePersist&quot;</span> <span class="na">method=</span><span class="s">&quot;setCreatedValue&quot;</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/lifecycle-callbacks&gt;</span>
    <span class="nt">&lt;/entity&gt;</span>
<span class="nt">&lt;/doctrine-mapping&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En el ejemplo anterior se supone que has creado y asignado una propiedad <tt class="docutils literal"><span class="pre">created</span></tt> (no mostrada aquí).</p>
</div>
<p>Ahora, justo antes de persistir la primer entidad, <em>Doctrine</em> automáticamente llamará a este método y establecerá el campo <tt class="docutils literal"><span class="pre">created</span></tt> a la fecha actual.</p>
<p>Esto se puede repetir en cualquiera de los otros eventos del ciclo de vida, los cuales incluyen a:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">preRemove</span></tt></li>
<li><tt class="docutils literal"><span class="pre">postRemove</span></tt></li>
<li><tt class="docutils literal"><span class="pre">prePersist</span></tt></li>
<li><tt class="docutils literal"><span class="pre">postPersist</span></tt></li>
<li><tt class="docutils literal"><span class="pre">preUpdate</span></tt></li>
<li><tt class="docutils literal"><span class="pre">postUpdate</span></tt></li>
<li><tt class="docutils literal"><span class="pre">postLoad</span></tt></li>
<li><tt class="docutils literal"><span class="pre">loadClassMetadata</span></tt></li>
</ul>
<p>Para más información sobre qué significan estos eventos y el ciclo de vida de las retrollamadas en general, consulta la sección <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#lifecycle-events">Ciclo de vida de los eventos</a> en la documentación de <em>Doctrine</em>.</p>
<div class="sidebar">
<p class="first sidebar-title">Ciclo de vida de retrollamada y escuchas de eventos</p>
<p>Observa que el método <tt class="docutils literal"><span class="pre">setCreatedValue()</span></tt> no recibe argumentos. Este siempre es el caso para el ciclo de vida de las retrollamadas y es intencional: el ciclo de vida de las retrollamadas debe ser un método sencillo que se ocupe de transformar los datos internos de la entidad (por ejemplo, estableciendo un campo a creado/actualizado, generando un valor ficticio).</p>
<p class="last">Si necesitas hacer alguna tarea más pesada &#8212;como llevar el registro de eventos o enviar un correo electrónico&#8212; debes registrar una clase externa como un escucha o suscriptor de eventos y darle acceso a todos los recursos que necesites. Para más información, consulta <a class="reference internal" href="../cookbook/doctrine/event_listeners_subscribers.html"><em>Registrando escuchas y suscriptores de eventos</em></a>.</p>
</div>
</div>
<div class="section" id="extensiones-doctrine-timestampable-sluggable-etc">
<h2>Extensiones <em>Doctrine</em>: <tt class="docutils literal"><span class="pre">Timestampable</span></tt>, <tt class="docutils literal"><span class="pre">Sluggable</span></tt>, etc.<a class="headerlink" href="#extensiones-doctrine-timestampable-sluggable-etc" title="Enlazar permanentemente con este título">¶</a></h2>
<p><em>Doctrine</em> es bastante flexible, y dispone de una serie de extensiones de terceros que te permiten realizar fácilmente tareas repetitivas y comunes en tus entidades.
Estas incluyen cosas tales como <tt class="docutils literal"><span class="pre">Sluggable</span></tt>, <tt class="docutils literal"><span class="pre">Timestampable</span></tt>, <tt class="docutils literal"><span class="pre">registrable</span></tt>, <tt class="docutils literal"><span class="pre">traducible</span></tt> y <tt class="docutils literal"><span class="pre">Tree</span></tt>.</p>
<p>Para más información sobre cómo encontrar y utilizar estas extensiones, ve el artículo sobre el uso de <a class="reference internal" href="../cookbook/doctrine/common_extensions.html"><em>extensiones comunes de Doctrine</em></a>.</p>
</div>
<div class="section" id="referencia-de-tipos-de-campo-doctrine">
<span id="book-doctrine-field-types"></span><h2>Referencia de tipos de campo <em>Doctrine</em><a class="headerlink" href="#referencia-de-tipos-de-campo-doctrine" title="Enlazar permanentemente con este título">¶</a></h2>
<p><em>Doctrine</em> dispone de una gran cantidad de tipos de campo. Cada uno de estos asigna un tipo de dato <em>PHP</em> a un tipo de columna específica en cualquier base de datos que estés utilizando. Los siguientes tipos son compatibles con <em>Doctrine</em>:</p>
<ul class="simple">
<li><strong>Cadenas</strong><ul>
<li><tt class="docutils literal"><span class="pre">string</span></tt> (usado para cadenas cortas)</li>
<li><tt class="docutils literal"><span class="pre">text</span></tt> (usado para cadenas grandes)</li>
</ul>
</li>
<li><strong>Números</strong><ul>
<li><tt class="docutils literal"><span class="pre">integer</span></tt></li>
<li><tt class="docutils literal"><span class="pre">smallint</span></tt></li>
<li><tt class="docutils literal"><span class="pre">bigint</span></tt></li>
<li><tt class="docutils literal"><span class="pre">decimal</span></tt></li>
<li><tt class="docutils literal"><span class="pre">float</span></tt></li>
</ul>
</li>
<li><strong>Fechas y horas</strong> (usa un objeto <a class="reference external" href="http://www.php.net/manual/es/class.datetime.php">DateTime</a> para estos campos en <em>PHP</em>)<ul>
<li><tt class="docutils literal"><span class="pre">date</span></tt></li>
<li><tt class="docutils literal"><span class="pre">time</span></tt></li>
<li><tt class="docutils literal"><span class="pre">datetime</span></tt></li>
</ul>
</li>
<li><strong>Otros tipos</strong><ul>
<li><tt class="docutils literal"><span class="pre">boolean</span></tt></li>
<li><tt class="docutils literal"><span class="pre">object</span></tt> (serializado y almacenado en un campo <tt class="docutils literal"><span class="pre">CLOB</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">array</span></tt> (serializado y almacenado en un campo <tt class="docutils literal"><span class="pre">CLOB</span></tt>)</li>
</ul>
</li>
</ul>
<p>Para más información, consulta la sección <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html#doctrine-mapping-types">Asignando tipos</a> en la documentación de <em>Doctrine</em>.</p>
<div class="section" id="opciones-de-campo">
<h3>Opciones de campo<a class="headerlink" href="#opciones-de-campo" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cada campo puede tener un conjunto de opciones aplicables. Las opciones disponibles incluyen <tt class="docutils literal"><span class="pre">type</span></tt> (el predeterminado es <tt class="docutils literal"><span class="pre">string</span></tt>), <tt class="docutils literal"><span class="pre">name</span></tt>, <tt class="docutils literal"><span class="pre">length</span></tt>, <tt class="docutils literal"><span class="pre">unique</span></tt> y <tt class="docutils literal"><span class="pre">nullable</span></tt>. Aquí tenemos algunos ejemplos:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Annotations</em><div class="highlight-php-annotations"><div class="highlight"><pre><span class="sd">/**</span>
<span class="sd"> * Un campo cadena con longitud de 255 que no puede ser nulo</span>
<span class="sd"> * (reflejando los valores predeterminados para las opciones &quot;type&quot;, &quot;length&quot; y &quot;nullable&quot;)</span>
<span class="sd"> *</span>
<span class="sd"> * @ORM\Column()</span>
<span class="sd"> */</span>
<span class="k">protected</span> <span class="nv">$name</span><span class="p">;</span>

<span class="sd">/**</span>
<span class="sd"> * Un campo cadena de longitud 150 que persiste a una columna &quot;email_address&quot; y tiene un índice único.</span>
<span class="sd"> *</span>
<span class="sd"> * @ORM\Column(name=&quot;email_address&quot;, unique=true, length=150)</span>
<span class="sd"> */</span>
<span class="k">protected</span> <span class="nv">$email</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">fields</span><span class="p-Indicator">:</span>
    <span class="c1"># Un campo cadena de longitud 255 que no puede ser null</span>
    <span class="c1"># (reflejando los valores predefinidos para las opciones &quot;length&quot; y &quot;nullable&quot;)</span>
    <span class="c1"># el atributo type es necesario en las definiciones yaml</span>
    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">string</span>

    <span class="c1"># Un campo cadena de longitud 150 que persiste a una columna &quot;email_address&quot;</span>
    <span class="c1"># y tiene un índice único.</span>
    <span class="l-Scalar-Plain">email</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">string</span>
        <span class="l-Scalar-Plain">column</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">email_address</span>
        <span class="l-Scalar-Plain">length</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">150</span>
        <span class="l-Scalar-Plain">unique</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Hay algunas opciones más que no figuran en esta lista. Para más detalles, consulta la sección <a class="reference external" href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html#property-mapping">Asignando propiedades</a> de la documentación de <em>Doctrine</em>.</p>
</div>
</div>
</div>
<div class="section" id="ordenes-de-consola">
<span id="index-2"></span><h2>Ordenes de consola<a class="headerlink" href="#ordenes-de-consola" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La integración del <em>ORM</em> de <em>Doctrine2</em> ofrece varias ordenes de consola bajo el espacio de nombres <tt class="docutils literal"><span class="pre">doctrine</span></tt>. Para ver la lista de ordenes puedes ejecutar la consola sin ningún tipo de argumento:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console
</pre></div>
</div>
<p>Mostrará una lista de ordenes disponibles, muchas de las cuales comienzan con el prefijo <tt class="docutils literal"><span class="pre">doctrine:</span></tt>. Puedes encontrar más información sobre cualquiera de estas ordenes (o cualquier orden de <em>Symfony</em>) ejecutando la orden <tt class="docutils literal"><span class="pre">help</span></tt>. Por ejemplo, para obtener detalles acerca de la tarea <tt class="docutils literal"><span class="pre">doctrine:database:create</span></tt>, ejecuta:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console <span class="nb">help </span>doctrine:database:create
</pre></div>
</div>
<p>Algunas tareas notables o interesantes son:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">doctrine:ensure-production-settings</span></tt> &#8212; comprueba si el entorno actual está configurado de manera eficiente para producción. Esta siempre se debe ejecutar en el entorno <tt class="docutils literal"><span class="pre">prod</span></tt>:</p>
<div class="highlight-bash"><div class="highlight"><pre>php app/console doctrine:ensure-production-settings --env<span class="o">=</span>prod
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">doctrine:mapping:import</span></tt> &#8212; permite a <em>Doctrine</em> llevar a cabo una introspección a una base de datos existente y crear información de asignación. Para más información, consulta <a class="reference internal" href="../cookbook/doctrine/reverse_engineering.html"><em>Cómo generar entidades desde una base de datos existente</em></a>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">doctrine:mapping:info</span></tt> &#8212; te dice todas las entidades de las que <em>Doctrine</em> es consciente y si hay algún error básico con la asignación.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">doctrine:query:dql</span></tt> y <tt class="docutils literal"><span class="pre">doctrine:query:sql</span></tt> &#8212; te permiten ejecutar consultas <em>DQL</em> o <em>SQL</em> directamente desde la línea de ordenes.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Para poder cargar accesorios a tu base de datos, en su lugar, necesitas tener instalado el paquete <tt class="docutils literal"><span class="pre">DoctrineFixturesBundle</span></tt>. Para aprender cómo hacerlo, lee el artículo &#8220;<a class="reference internal" href="../bundles/DoctrineFixturesBundle/index.html"><em>DoctrineFixturesBundle</em></a>&#8221; en la documentación.</p>
</div>
</div>
<div class="section" id="resumen">
<h2>Resumen<a class="headerlink" href="#resumen" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Con <em>Doctrine</em>, puedes centrarte en tus objetos y la forma en que son útiles en tu aplicación y luego preocuparte por su persistencia en la base de datos. Esto se debe a que <em>Doctrine</em> te permite utilizar cualquier objeto <em>PHP</em> para almacenar los datos y se basa en la información de asignación de metadatos para asignar los datos de un objeto a una tabla particular de la base de datos.</p>
<p>Y aunque <em>Doctrine</em> gira en torno a un concepto simple, es increíblemente poderoso, permitiéndote crear consultas complejas y suscribirte a los eventos que te permiten realizar diferentes acciones conforme los objetos recorren su ciclo de vida en la persistencia.</p>
<p>Para más información acerca de <em>Doctrine</em>, ve la sección <em>Doctrine</em> del <a class="reference internal" href="../cookbook/index.html"><em>recetario</em></a>, que incluye los siguientes artículos:</p>
<ul class="simple">
<li><a class="reference internal" href="../bundles/DoctrineFixturesBundle/index.html"><em>DoctrineFixturesBundle</em></a></li>
<li><a class="reference internal" href="../cookbook/doctrine/common_extensions.html"><em>Extensiones Doctrine: Timestampable, Sluggable, Translatable, etc.</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <a href="https://github.com/symfony/symfony-standard"><img style="position: fixed; top: 0; right: 0; border: 0;" src="http://gitnacho.github.com/tnp/img/comun/bifurcame.png" alt="Bifúrcame en GitHub" /></a>
  
  <div style="width:740px;margin:10px auto;">
    
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="testing.html" title="Probando"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="templating.html" title="Creando y usando plantillas"
             >anterior</a> |</li>
        <li><a href="../index.html">en Español</a> &raquo;</li>
          <li><a href="index.html" >Libro</a> &raquo;</li> 
      </ul>
    </div>
  </div>


   <div style="width: 740px; margin: 0 auto;">
     <div id="disqus_thread"></div>
     
    <div class="footer">
        &copy; Copyright 2011-2012, Traducido por Nacho Pacheco.
      Actualizado por última vez en Apr 23, 2012.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
   </div>
   <script type="text/javascript">
    var disqus_shortname = 'documentos-mx';
    var disqus_developer = 1;
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
   </script>
   <noscript>
     Por favor activa JavaScript para ver los <a href="http://disqus.com/?ref_noscript">comentarios accionados por Disqus.</a>
   </noscript>

  </body>
</html>