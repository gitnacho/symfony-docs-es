
<!DOCTYPE html> 
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Compilando el contenedor &mdash; Manual de Symfony2 en Español</title>
    
    <link rel="stylesheet" href="../../_static/tnp.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.0.15',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <link rel="shortcut icon" href="../../_static/icotnp.ico"/>
    <link rel="top" title="Manual de Symfony2 en Español" href="../../index.html" />
    <link rel="up" title="Inyección de dependencias" href="index.html" />
    <link rel="next" title="Trabajando con servicios etiquetados" href="tags.html" />
    <link rel="prev" title="Trabajando con contenedores de parámetros y definiciones" href="definitions.html" /> 
  </head>
  <body>
  <div class="imalogo">
    
  <a href="../../index.html"><img src="http://gitnacho.github.com/tnp/img/sf/logo-big.gif" alt="Edición estándar de Symfony2" />
  
    <a href="../../index.html"><img src="http://gitnacho.github.com/tnp/_static/normaltnp.png" alt="Traducciones de Nacho Pacheco" /></a>
    <div class="social">
      <a href="https://twitter.com/share" class="twitter-share-button" data-via="esymfony" data-lang="es">Tweet</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    </div>
    <div id="searchbox">
      <form class="searc " action="../../search.html" method="get">
      <input type="search" name="q" placeholder="Término a buscar" />
      <input type="submit" value="Ir" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
    

    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="tags.html" title="Trabajando con servicios etiquetados"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="definitions.html" title="Trabajando con contenedores de parámetros y definiciones"
             accesskey="P">anterior</a> |</li>
        <li><a href="../../index.html">en Español</a> &raquo;</li>
          <li><a href="../index.html" >Componentes</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Inyección de dependencias</a> &raquo;</li> 
      </ul>
    </div>
  </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="compilando-el-contenedor">
<span id="index-0"></span><h1>Compilando el contenedor<a class="headerlink" href="#compilando-el-contenedor" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El contenedor de servicios se puede compilar por varios motivos. Estas razones incluyen la comprobación de posibles problemas, tal como referencias circulares y volver más eficiente al contenedor usando la resolución de parámetros y remoción de servicios no utilizados.</p>
<p>Se compila ejecutando:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$container</span><span class="o">-&gt;</span><span class="na">compile</span><span class="p">();</span>
</pre></div>
</div>
<p>El método de compilación utiliza &#8220;<tt class="docutils literal"><span class="pre">Compiler</span> <span class="pre">Passes</span></tt>&#8221; para la compilación. El componente <em>Inyección de dependencias</em> viene con varios pases que se registran automáticamente para la compilación. Por ejemplo, la clase <tt class="xref php php-class docutils literal"><span class="pre">Symfony\Component\DependencyInjection\Compiler\CheckDefinitionValidityPass</span></tt> comprueba varios potenciales problemas relacionados con las definiciones que se han establecido en el contenedor. Después de este y varios otros pases que comprueban la validez del contenedor, se utilizan pases adicionales del compilador para optimizar la configuración antes de almacenarla en caché. Por ejemplo, se quitan los servicios privados y abstractos, y se resuelven los alias.</p>
<div class="section" id="gestionando-la-configuracion-con-extensiones">
<span id="components-dependency-injection-extension"></span><h2>Gestionando la configuración con extensiones<a class="headerlink" href="#gestionando-la-configuracion-con-extensiones" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Así como cargar la configuración directamente en el contenedor como se muestra en <a class="reference internal" href="introduction.html"><em>El componente Inyección de dependencias</em></a>, la puedes gestionar registrando extensiones en el contenedor. El primer paso en el proceso de compilación es cargar en el contenedor la configuración de cualquier clase registrada en la extensión. A diferencia de la configuración cargada directamente, esta sólo se procesa cuándo el contenedor es compilado. Si tu aplicación es modular entonces las extensiones dejan que cada módulo registre y gestione su propio servicio de configuración.</p>
<p>Las extensiones deben implementar la <tt class="xref php php-class docutils literal"><span class="pre">Symfony\Component\DependencyInjection\Extension\ExtensionInterface</span></tt> y las puedes registrar en el contenedor con:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$container</span><span class="o">-&gt;</span><span class="na">registerExtension</span><span class="p">(</span><span class="nv">$extension</span><span class="p">);</span>
</pre></div>
</div>
<p>El trabajo principal de la extensión se realiza en el método <tt class="docutils literal"><span class="pre">load</span></tt>. En el método <tt class="docutils literal"><span class="pre">load</span></tt> puedes cargar la configuración desde uno o más archivos de configuración, así como manipular las definiciones del contenedor utilizando los métodos indicados en <a class="reference internal" href="definitions.html"><em>Trabajando con contenedores de parámetros y definiciones</em></a>.</p>
<p>Al método <tt class="docutils literal"><span class="pre">load</span></tt> se le pasa un nuevo contenedor para configurarlo, el cual posteriormente se fusiona en el contenedor con el que se haya registrado. Esto te permite tener varias extensiones para gestionar las definiciones del contenedor de forma independiente.
Las extensiones no agregan configuración a los contenedores cuando se añaden, pero se procesan cuando se llama al método <tt class="docutils literal"><span class="pre">compile</span></tt> del contenedor.</p>
<p>Una muy sencilla extensión puede justo cargar al contenedor archivos de configuración:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Loader\XmlFileLoader</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Extension\ExtensionInterface</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Config\FileLocator</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AcmeDemoExtension</span> <span class="k">implements</span> <span class="nx">ExtensionInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$loader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XmlFileLoader</span><span class="p">(</span>
            <span class="nv">$container</span><span class="p">,</span>
            <span class="k">new</span> <span class="nx">FileLocator</span><span class="p">(</span><span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../Resources/config&#39;</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="s1">&#39;services.xml&#39;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Esto no mejora mucho comparado a cargar el archivo directamente al construir el contenedor global. Justo deja los archivos para ser divididos entre módulos/paquetes. Para poder afectar la configuración de un módulo desde archivos de configuración externos al módulo/paquete es necesario hacer configurable una aplicación compleja. Esto se puede hacer especificando se carguen secciones de archivos de configuración directamente al contenedor cuando son para una extensión en particular. Estas secciones en la configuración no serán procesadas directamente por el contenedor sino por la extensión pertinente.</p>
<p>La extensión debe especificar un método <tt class="docutils literal"><span class="pre">getAlias</span></tt> para implementar la interfaz:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// ...</span>

<span class="k">class</span> <span class="nc">AcmeDemoExtension</span> <span class="k">implements</span> <span class="nx">ExtensionInterface</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getAlias</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s1">&#39;acme_demo&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Para archivos de configuración <em>YAML</em> especificar el alias para la extensión como clave significará que aquellos valores se pasan al método <tt class="docutils literal"><span class="pre">load</span></tt> de la extensión:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># ...</span>
<span class="l-Scalar-Plain">acme_demo</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">foo</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fooValue</span>
    <span class="l-Scalar-Plain">bar</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">barValue</span>
</pre></div>
</div>
<p>Si este archivo se carga en la configuración entonces los valores en él sólo son
procesados cuándo el contenedor es compilado en el punto que se cargan las extensiones:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Config\FileLocator</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Loader\YamlFileLoader</span><span class="p">;</span>

<span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">();</span>
<span class="nv">$loader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YamlFileLoader</span><span class="p">(</span><span class="nv">$container</span><span class="p">,</span> <span class="k">new</span> <span class="nx">FileLocator</span><span class="p">(</span><span class="nx">__DIR__</span><span class="p">));</span>
<span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="s1">&#39;config.yml&#39;</span><span class="p">);</span>

<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">registerExtension</span><span class="p">(</span><span class="k">new</span> <span class="nx">AcmeDemoExtension</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">compile</span><span class="p">();</span>
</pre></div>
</div>
<p>Los valores de esas secciones de los archivos de configuración son pasados en el primer
argumento del método <tt class="docutils literal"><span class="pre">load</span></tt> de la extensión:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$foo</span> <span class="o">=</span> <span class="nv">$configs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;foo&#39;</span><span class="p">];</span> <span class="c1">//fooValue</span>
    <span class="nv">$bar</span> <span class="o">=</span> <span class="nv">$configs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;bar&#39;</span><span class="p">];</span> <span class="c1">//barValue</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El argumento <tt class="docutils literal"><span class="pre">$configs</span></tt> es un arreglo conteniendo cada diferente archivo de configuración que se carga en el contenedor. Sólo estás cargando un único archivo de configuración en el ejemplo anterior pero todavía será en un arreglo. El arreglo se verá como este:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">array</span><span class="p">(</span>
    <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;foo&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;fooValue&#39;</span><span class="p">,</span>
        <span class="s1">&#39;bar&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;barValue&#39;</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Si bien puedes gestionar manualmente la fusión de diferentes archivos, es mucho mejor
utilizar el <a class="reference internal" href="../config/introduction.html"><em>componente Config</em></a> para combinar
y validar los valores de configuración. Usando el procesamiento de configuración podrías acceder a los valores de configuración de la siguiente manera:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\Config\Definition\Processor</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$configuration</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Configuration</span><span class="p">();</span>
    <span class="nv">$processor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Processor</span><span class="p">();</span>
    <span class="nv">$config</span> <span class="o">=</span> <span class="nv">$processor</span><span class="o">-&gt;</span><span class="na">processConfiguration</span><span class="p">(</span><span class="nv">$configuration</span><span class="p">,</span> <span class="nv">$configs</span><span class="p">);</span>

    <span class="nv">$foo</span> <span class="o">=</span> <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">];</span> <span class="c1">//fooValue</span>
    <span class="nv">$bar</span> <span class="o">=</span> <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">];</span> <span class="c1">//barValue</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Aun faltan dos métodos que debes implementar. Uno para regresar el espacio de nombres <em>XML</em> de modo que las partes pertinentes de un archivo de configuración <em>XML</em> es pasado a la extensión. El otro para especificar la ruta a los archivos <em>XSD</em> base para validar la configuración <em>XML</em>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">getXsdValidationBasePath</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../Resources/config/&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">getNamespace</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;http://www.ejemplo.com/symfony/schema/&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">La validación <em>XSD</em> es opcional, regresando <tt class="docutils literal"><span class="pre">false</span></tt> desde el método <tt class="docutils literal"><span class="pre">getXsdValidationBasePath</span></tt> lo inhabilitará.</p>
</div>
<p>La versión <em>XML</em> de la configuración entonces se parecería a esta:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; ?&gt;</span>
<span class="nt">&lt;container</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/dic/services&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xmlns:acme_demo=</span><span class="s">&quot;http://www.example.com/symfony/schema/&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.example.com/symfony/schema/ http://www.example.com/symfony/schema/hello-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;acme_demo:config&gt;</span>
        <span class="nt">&lt;acme_demo:foo&gt;</span>fooValue<span class="nt">&lt;/acme_hello:foo&gt;</span>
        <span class="nt">&lt;acme_demo:bar&gt;</span>barValue<span class="nt">&lt;/acme_demo:bar&gt;</span>
    <span class="nt">&lt;/acme_demo:config&gt;</span>

<span class="nt">&lt;/container&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En la plataforma <em>Symfony2</em> completa hay una clase <tt class="docutils literal"><span class="pre">Extensión</span></tt> base que implementa estos métodos así como un acceso directo al método para procesar la configuración. Consulta <a class="reference internal" href="../../cookbook/bundles/extension.html"><em>Cómo exponer la configuración semántica de un paquete</em></a> para más detalles.</p>
</div>
<p>El valor de configuración procesado ahora se puede añadir como parámetro del contenedor como si estuviera enumerado en una sección <tt class="docutils literal"><span class="pre">parameters</span></tt> del archivo de configuración pero con el beneficio adicional de fusionar y validar múltiples archivos de configuración:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$configuration</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Configuration</span><span class="p">();</span>
    <span class="nv">$processor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Processor</span><span class="p">();</span>
    <span class="nv">$config</span> <span class="o">=</span> <span class="nv">$processor</span><span class="o">-&gt;</span><span class="na">processConfiguration</span><span class="p">(</span><span class="nv">$configuration</span><span class="p">,</span> <span class="nv">$configs</span><span class="p">);</span>

    <span class="nv">$container</span><span class="o">-&gt;</span><span class="na">setParameter</span><span class="p">(</span><span class="s1">&#39;acme_demo.FOO&#39;</span><span class="p">,</span> <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]);</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Puedes proveer requisitos de configuración más complejos para las clases en la extensión. Por ejemplo, puedes elegir cargar un archivo de configuración de un servicio principal pero también cargar uno secundario sólo si se ajusta un determinado parámetro:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$configuration</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Configuration</span><span class="p">();</span>
    <span class="nv">$processor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Processor</span><span class="p">();</span>
    <span class="nv">$config</span> <span class="o">=</span> <span class="nv">$processor</span><span class="o">-&gt;</span><span class="na">processConfiguration</span><span class="p">(</span><span class="nv">$configuration</span><span class="p">,</span> <span class="nv">$configs</span><span class="p">);</span>

    <span class="nv">$loader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XmlFileLoader</span><span class="p">(</span>
        <span class="nv">$container</span><span class="p">,</span>
        <span class="k">new</span> <span class="nx">FileLocator</span><span class="p">(</span><span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../Resources/config&#39;</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="s1">&#39;services.xml&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;advanced&#39;</span><span class="p">])</span> <span class="p">{</span>
        <span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="s1">&#39;advanced.xml&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si necesitas manipular la configuración cargada por una extensión, entonces no lo puedes hacer desde otra extensión, ya que esta utiliza un contenedor nuevo.
En su lugar, debes utilizar un pase del compilador que trabaje con el contenedor completo después de haber procesado las extensiones.</p>
</div>
</div>
<div class="section" id="anadiendo-al-principio-la-configuracion-pasada-a-la-extension">
<span id="components-dependency-injection-compiler-passes"></span><h2>Añadiendo al principio la configuración pasada a la extensión<a class="headerlink" href="#anadiendo-al-principio-la-configuracion-pasada-a-la-extension" title="Enlazar permanentemente con este título">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">Nuevo en la versión 2.2: </span>La habilidad para añadir al principio la configuración de un paquete es nueva en <em>Symfony 2.2</em>.</p>
<p>Una extensión puede añadir al principio la configuración de cualquier paquete antes de invocar al método <tt class="docutils literal"><span class="pre">load()</span></tt> implementando la clase <tt class="xref php php-class docutils literal"><span class="pre">Symfony\Component\DependencyInjection\Compiler\PrependExtensionInterface</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Compiler\PrependExtensionInterface</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">class</span> <span class="nc">AcmeDemoExtension</span> <span class="k">implements</span> <span class="nx">ExtensionInterface</span><span class="p">,</span> <span class="nx">PrependExtensionInterface</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">prepend</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>

        <span class="nv">$container</span><span class="o">-&gt;</span><span class="na">prependExtensionConfig</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$config</span><span class="p">);</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Para más detalles, ve <a class="reference internal" href="../../cookbook/bundles/prepend_extension.html"><em>Cómo simplificar la configuración de múltiples paquetes</em></a>, la cual es específica a la plataforma <em>Symfony2</em>, pero contiene más detalles sobre esta característica.</p>
</div>
<div class="section" id="creando-un-pase-del-compilador">
<h2>Creando un pase del compilador<a class="headerlink" href="#creando-un-pase-del-compilador" title="Enlazar permanentemente con este título">¶</a></h2>
<p>También puedes crear y registrar tu propio pase del compilador en el contenedor.
Para crear un pase del compilador tienes que implementar la interfaz <tt class="xref php php-class docutils literal"><span class="pre">Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface</span></tt>. El compilador te brinda la oportunidad de manipular las definiciones de los servicios que se han compilado. Esto puede ser muy poderoso, pero no es algo necesario en el uso cotidiano.</p>
<p>El pase del compilador debe tener el método <tt class="docutils literal"><span class="pre">process</span></tt> que se pasa al contenedor compilado:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CustomCompilerPass</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">process</span><span class="p">(</span><span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los parámetros del contenedor y las definiciones se pueden manipular usando los métodos descritos en <a class="reference internal" href="definitions.html"><em>Trabajando con contenedores de parámetros y definiciones</em></a>.
Una cosa común por hacer en un pase del compilador es buscar todos los servicios que tienen una determinada etiqueta, a fin de procesarla de alguna manera o dinámicamente conectar cada una con algún otro servicio.</p>
</div>
<div class="section" id="registrando-un-pase-del-compilador">
<h2>Registrando un pase del compilador<a class="headerlink" href="#registrando-un-pase-del-compilador" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Necesitas registrar tu pase personalizado del compilador en el contenedor. El método <tt class="docutils literal"><span class="pre">process</span></tt> será llamado al compilar el contenedor:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>

<span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">();</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">addCompilerPass</span><span class="p">(</span><span class="k">new</span> <span class="nx">CustomCompilerPass</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Los pases del compilador son registrados de manera diferente si estás usando la pila completa de la plataforma, ve <a class="reference internal" href="../../cookbook/service_container/compiler_passes.html"><em>Cómo trabajan los pases del compilador en los paquetes</em></a> para más detalles.</p>
</div>
<div class="section" id="controlando-el-orden-de-los-pases">
<h3>Controlando el orden de los pases<a class="headerlink" href="#controlando-el-orden-de-los-pases" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los pases predeterminados del compilador se agrupan en pases de optimización y pases de remoción. Los pases de optimización se ejecutan primero e incluyen tareas como la resolución de referencias con las definiciones. Los pases de remoción realizan tareas tales como la eliminación de alias privados y servicios no utilizados. Puedes elegir en qué orden se ejecutará cualquier pase personalizado que añadas. De manera predeterminada, se ejecutará antes de los pases de optimización.</p>
<p>Puedes utilizar las siguientes constantes como segundo argumento al registrar un pase en el contenedor para controlar en qué orden va:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">PassConfig::TYPE_BEFORE_OPTIMIZATION</span></tt></li>
<li><tt class="docutils literal"><span class="pre">PassConfig::TYPE_OPTIMIZE</span></tt></li>
<li><tt class="docutils literal"><span class="pre">PassConfig::TYPE_BEFORE_REMOVING</span></tt></li>
<li><tt class="docutils literal"><span class="pre">PassConfig::TYPE_REMOVE</span></tt></li>
<li><tt class="docutils literal"><span class="pre">PassConfig::TYPE_AFTER_REMOVING</span></tt></li>
</ul>
<p>Por ejemplo, para correr tu pase personalizado después de quitar el pase predeterminado tienes que ejecutar:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Compiler\PassConfig</span><span class="p">;</span>

<span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">();</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">addCompilerPass</span><span class="p">(</span>
    <span class="k">new</span> <span class="nx">CustomCompilerPass</span><span class="p">,</span>
    <span class="nx">PassConfig</span><span class="o">::</span><span class="na">TYPE_AFTER_REMOVING</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="vertiendo-la-configuracion-para-mejorar-el-rendimiento">
<span id="components-dependency-injection-dumping"></span><h2>Vertiendo la configuración para mejorar el rendimiento<a class="headerlink" href="#vertiendo-la-configuracion-para-mejorar-el-rendimiento" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Puede ser mucho más fácil entender el uso de los archivos de configuración para gestionar el contenedor de servicios que usar <em>PHP</em> una vez que hay una gran cantidad de servicios. Esta facilidad tiene un costo, aunque cuando se trata de rendimiento, puesto que los archivos de configuración se tienen que analizar y la configuración de <em>PHP</em> construida desde ellos. El proceso de compilación hace más eficiente al contenedor pero toma tiempo su ejecución. Puedes tener lo mejor de ambos mundos aunque usando archivos de configuración y, luego vertiendo y almacenando en caché la configuración resultante. El <tt class="docutils literal"><span class="pre">PhpDumper</span></tt> fácilmente vierte el contenedor compilado:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Dumper\PhpDumper</span><span class="p">;</span>

<span class="nv">$file</span> <span class="o">=</span> <span class="nx">__DIR__</span> <span class="o">.</span><span class="s1">&#39;/cache/container.php&#39;</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">file_exists</span><span class="p">(</span><span class="nv">$file</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">require_once</span> <span class="nv">$file</span><span class="p">;</span>
    <span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ProjectServiceContainer</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="nv">$container</span><span class="o">-&gt;</span><span class="na">compile</span><span class="p">();</span>

    <span class="nv">$dumper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PhpDumper</span><span class="p">(</span><span class="nv">$container</span><span class="p">);</span>
    <span class="nb">file_put_contents</span><span class="p">(</span><span class="nv">$file</span><span class="p">,</span> <span class="nv">$dumper</span><span class="o">-&gt;</span><span class="na">dump</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">ProjectServiceContainer</span></tt> es el nombre predeterminado aplicado a la clase vertida en el contenedor, aun así, lo puedes cambiar con la opción <tt class="docutils literal"><span class="pre">class</span></tt> cuándo lo viertes:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// ...</span>
<span class="nv">$file</span> <span class="o">=</span> <span class="nx">__DIR__</span> <span class="o">.</span><span class="s1">&#39;/cache/container.php&#39;</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">file_exists</span><span class="p">(</span><span class="nv">$file</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">require_once</span> <span class="nv">$file</span><span class="p">;</span>
    <span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyCachedContainer</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="nv">$container</span><span class="o">-&gt;</span><span class="na">compile</span><span class="p">();</span>

    <span class="nv">$dumper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PhpDumper</span><span class="p">(</span><span class="nv">$container</span><span class="p">);</span>
    <span class="nb">file_put_contents</span><span class="p">(</span>
        <span class="nv">$file</span><span class="p">,</span>
        <span class="nv">$dumper</span><span class="o">-&gt;</span><span class="na">dump</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;class&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;MyCachedContainer&#39;</span><span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora obtendrás la velocidad del contenedor <em>PHP</em> configurado con &#8212;los fáciles de usar&#8212; archivos de configuración. Además verter el contenedor de este modo optimiza aún más la manera en que son creados los servicios por el contenedor.</p>
<p>En el ejemplo anterior tendrás que borrar los archivos del contenedor memorizados en caché cada vez que hagas algún cambio. Añadir una comprobación por una variable que determina si estás en modo de depuración te permite mantener la velocidad del contenedor memorizado en caché en producción, sino consiguiendo una actualización de la configuración, mientras desarrollas tu aplicación:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// ...</span>

<span class="c1">// basándose en algo de tu proyecto</span>
<span class="nv">$isDebug</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="nv">$file</span> <span class="o">=</span> <span class="nx">__DIR__</span> <span class="o">.</span><span class="s1">&#39;/cache/container.php&#39;</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$isDebug</span> <span class="o">&amp;&amp;</span> <span class="nb">file_exists</span><span class="p">(</span><span class="nv">$file</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">require_once</span> <span class="nv">$file</span><span class="p">;</span>
    <span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyCachedContainer</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="nv">$container</span><span class="o">-&gt;</span><span class="na">compile</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$isDebug</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$dumper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PhpDumper</span><span class="p">(</span><span class="nv">$container</span><span class="p">);</span>
        <span class="nb">file_put_contents</span><span class="p">(</span>
            <span class="nv">$file</span><span class="p">,</span>
            <span class="nv">$dumper</span><span class="o">-&gt;</span><span class="na">dump</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;class&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;MyCachedContainer&#39;</span><span class="p">))</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Esto se podría mejorar aún más únicamente recompilando el contenedor en modo de depuración cuándo se han hecho cambios a su configuración en lugar de en cada petición. Esto se puede hacer memorizando en caché los archivos de recurso usados para configurar el contenedor de la manera descrita en «<a class="reference internal" href="../config/caching.html"><em>Almacenamiento en caché basado en recursos</em></a>» en la documentación de configuración del componente.</p>
<p>No necesitas preocuparte de cuál archivo memorizar en caché puesto que el constructor del contenedor mantiene la pista de todos los recursos utilizados para configurarlo, no solo los archivos de configuración sino las clases de extensión y pases del compilador también. Esto significa que cualquier cambio a cualquiera de estos archivos invalidará la caché y provocará la reconstrucción del contenedor. Sólo necesitas preguntar el contenedor por estos recursos y utilizarlos como metadatos para la caché:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// ...</span>

<span class="c1">// basándose en algo de tu proyecto</span>
<span class="nv">$isDebug</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="nv">$file</span> <span class="o">=</span> <span class="nx">__DIR__</span> <span class="o">.</span><span class="s1">&#39;/cache/container.php&#39;</span><span class="p">;</span>
<span class="nv">$containerConfigCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ConfigCache</span><span class="p">(</span><span class="nv">$file</span><span class="p">,</span> <span class="nv">$isDebug</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$containerConfigCache</span><span class="o">-&gt;</span><span class="na">isFresh</span><span class="p">())</span> <span class="p">{</span>
    <span class="nv">$containerBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">compile</span><span class="p">();</span>

    <span class="nv">$dumper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PhpDumper</span><span class="p">(</span><span class="nv">$containerBuilder</span><span class="p">);</span>
    <span class="nv">$containerConfigCache</span><span class="o">-&gt;</span><span class="na">write</span><span class="p">(</span>
        <span class="nv">$dumper</span><span class="o">-&gt;</span><span class="na">dump</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;class&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;MyCachedContainer&#39;</span><span class="p">)),</span>
        <span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">getResources</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">require_once</span> <span class="nv">$file</span><span class="p">;</span>
<span class="nv">$container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyCachedContainer</span><span class="p">();</span>
</pre></div>
</div>
<p>Ahora la caché vertida al contenedor se utiliza independientemente de si el modo de depuración está activo o no.
La diferencia es que el <tt class="docutils literal"><span class="pre">ConfigCache</span></tt> está puesto en modo para depurar con su segundo
argumento del constructor. Cuándo la caché no está en modo de depuración siempre se utilizará el contenedor memorizado en caché, si existe. En modo de depuración, un archivo de metadatos adicional se escribe con la marca de tiempo de todos los archivos de recursos. Entonces, estos se comprueban para ver si los archivos han cambiado, si están en caché se consideran viejos.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En la pila completa de la plataforma se tiene cuidado por ti de la compilación y almacenamiento en caché del contenedor.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <a href="https://github.com/symfony/symfony-standard"><img style="position: fixed; top: 0; right: 0; border: 0;" src="http://gitnacho.github.com/tnp/img/comun/bifurcame.png" alt="Bifúrcame en GitHub" /></a>
  
  <div style="width:740px;margin:10px auto;">
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="tags.html" title="Trabajando con servicios etiquetados"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="definitions.html" title="Trabajando con contenedores de parámetros y definiciones"
             >anterior</a> |</li>
        <li><a href="../../index.html">en Español</a> &raquo;</li>
          <li><a href="../index.html" >Componentes</a> &raquo;</li>
          <li><a href="index.html" >Inyección de dependencias</a> &raquo;</li> 
      </ul>
    </div>
  </div>


   <div style="width: 740px; margin: 0 auto;">
     <div id="disqus_thread"></div>
     
    <div class="footer">
        &copy; Copyright 2011-2013, Traducido por Nacho Pacheco.
      Actualizado por última vez en Jan 17, 2013.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
   </div>
   <script type="text/javascript">
    var disqus_shortname = 'documentos-mx';
    var disqus_developer = 1;
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
   </script>
   <noscript>
     Por favor activa JavaScript para ver los <a href="http://disqus.com/?ref_noscript">comentarios accionados por Disqus.</a>
   </noscript>

  </body>
</html>